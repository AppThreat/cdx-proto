// @generated by protoc-gen-es v1.8.0 with parameter "target=ts"
// @generated from file bom-1.6.proto (package cyclonedx.v1_6, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from enum cyclonedx.v1_6.Classification
 */
export enum Classification {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: CLASSIFICATION_NULL = 0;
   */
  NULL = 0,

  /**
   * A software application. Refer to https://en.wikipedia.org/wiki/Application_software for information about applications.
   *
   * @generated from enum value: CLASSIFICATION_APPLICATION = 1;
   */
  APPLICATION = 1,

  /**
   * A software framework. Refer to https://en.wikipedia.org/wiki/Software_framework for information on how frameworks vary slightly from libraries.
   *
   * @generated from enum value: CLASSIFICATION_FRAMEWORK = 2;
   */
  FRAMEWORK = 2,

  /**
   * A software library. Refer to https://en.wikipedia.org/wiki/Library_(computing) for information about libraries. All third-party and open source reusable components will likely be a library. If the library also has key features of a framework, then it should be classified as a framework. If not, or is unknown, then specifying library is recommended.
   *
   * @generated from enum value: CLASSIFICATION_LIBRARY = 3;
   */
  LIBRARY = 3,

  /**
   * A software operating system without regard to deployment model (i.e. installed on physical hardware, virtual machine, image, etc) Refer to https://en.wikipedia.org/wiki/Operating_system
   *
   * @generated from enum value: CLASSIFICATION_OPERATING_SYSTEM = 4;
   */
  OPERATING_SYSTEM = 4,

  /**
   * A hardware device such as a processor, or chip-set. A hardware device containing firmware should include a component for the physical hardware itself, and another component of type 'firmware' or 'operating-system' (whichever is relevant), describing information about the software running on the device. See also the list of known device properties: https://github.com/CycloneDX/cyclonedx-property-taxonomy/blob/main/cdx/device.md
   *
   * @generated from enum value: CLASSIFICATION_DEVICE = 5;
   */
  DEVICE = 5,

  /**
   * A computer file. Refer to https://en.wikipedia.org/wiki/Computer_file for information about files.
   *
   * @generated from enum value: CLASSIFICATION_FILE = 6;
   */
  FILE = 6,

  /**
   * A packaging and/or runtime format, not specific to any particular technology, which isolates software inside the container from software outside of a container through virtualization technology. Refer to https://en.wikipedia.org/wiki/OS-level_virtualization
   *
   * @generated from enum value: CLASSIFICATION_CONTAINER = 7;
   */
  CONTAINER = 7,

  /**
   * A special type of software that provides low-level control over a devices hardware. Refer to https://en.wikipedia.org/wiki/Firmware
   *
   * @generated from enum value: CLASSIFICATION_FIRMWARE = 8;
   */
  FIRMWARE = 8,

  /**
   * A special type of software that operates or controls a particular type of device. Refer to https://en.wikipedia.org/wiki/Device_driver
   *
   * @generated from enum value: CLASSIFICATION_DEVICE_DRIVER = 9;
   */
  DEVICE_DRIVER = 9,

  /**
   * A runtime environment which interprets or executes software. This may include runtimes such as those that execute bytecode or low-code/no-code application platforms.
   *
   * @generated from enum value: CLASSIFICATION_PLATFORM = 10;
   */
  PLATFORM = 10,

  /**
   * A model based on training data that can make predictions or decisions without being explicitly programmed to do so.
   *
   * @generated from enum value: CLASSIFICATION_MACHINE_LEARNING_MODEL = 11;
   */
  MACHINE_LEARNING_MODEL = 11,

  /**
   * A collection of discrete values that convey information.
   *
   * @generated from enum value: CLASSIFICATION_DATA = 12;
   */
  DATA = 12,

  /**
   * A cryptographic asset including algorithms, protocols, certificates, keys, tokens, and secrets.
   *
   * @generated from enum value: CLASSIFICATION_CRYPTOGRAPHIC_ASSET = 13;
   */
  CRYPTOGRAPHIC_ASSET = 13,
}
// Retrieve enum metadata with: proto3.getEnumType(Classification)
proto3.util.setEnumType(Classification, "cyclonedx.v1_6.Classification", [
  { no: 0, name: "CLASSIFICATION_NULL" },
  { no: 1, name: "CLASSIFICATION_APPLICATION" },
  { no: 2, name: "CLASSIFICATION_FRAMEWORK" },
  { no: 3, name: "CLASSIFICATION_LIBRARY" },
  { no: 4, name: "CLASSIFICATION_OPERATING_SYSTEM" },
  { no: 5, name: "CLASSIFICATION_DEVICE" },
  { no: 6, name: "CLASSIFICATION_FILE" },
  { no: 7, name: "CLASSIFICATION_CONTAINER" },
  { no: 8, name: "CLASSIFICATION_FIRMWARE" },
  { no: 9, name: "CLASSIFICATION_DEVICE_DRIVER" },
  { no: 10, name: "CLASSIFICATION_PLATFORM" },
  { no: 11, name: "CLASSIFICATION_MACHINE_LEARNING_MODEL" },
  { no: 12, name: "CLASSIFICATION_DATA" },
  { no: 13, name: "CLASSIFICATION_CRYPTOGRAPHIC_ASSET" },
]);

/**
 * Specifies the flow direction of the data. Valid values are: inbound, outbound, bi-directional, and unknown. Direction is relative to the service. Inbound flow states that data enters the service. Outbound flow states that data leaves the service. Bi-directional states that data flows both ways, and unknown states that the direction is not known.
 * buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "DATA_FLOW_DIRECTION_"
 *
 * @generated from enum cyclonedx.v1_6.DataFlowDirection
 */
export enum DataFlowDirection {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: DATA_FLOW_NULL = 0;
   */
  DATA_FLOW_NULL = 0,

  /**
   * @generated from enum value: DATA_FLOW_INBOUND = 1;
   */
  DATA_FLOW_INBOUND = 1,

  /**
   * @generated from enum value: DATA_FLOW_OUTBOUND = 2;
   */
  DATA_FLOW_OUTBOUND = 2,

  /**
   * @generated from enum value: DATA_FLOW_BI_DIRECTIONAL = 3;
   */
  DATA_FLOW_BI_DIRECTIONAL = 3,

  /**
   * @generated from enum value: DATA_FLOW_UNKNOWN = 4;
   */
  DATA_FLOW_UNKNOWN = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(DataFlowDirection)
proto3.util.setEnumType(DataFlowDirection, "cyclonedx.v1_6.DataFlowDirection", [
  { no: 0, name: "DATA_FLOW_NULL" },
  { no: 1, name: "DATA_FLOW_INBOUND" },
  { no: 2, name: "DATA_FLOW_OUTBOUND" },
  { no: 3, name: "DATA_FLOW_BI_DIRECTIONAL" },
  { no: 4, name: "DATA_FLOW_UNKNOWN" },
]);

/**
 * @generated from enum cyclonedx.v1_6.ExternalReferenceType
 */
export enum ExternalReferenceType {
  /**
   * Use this if no other types accurately describe the purpose of the external reference
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `other` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_OTHER = 0;
   */
  OTHER = 0,

  /**
   * Version Control System
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_VCS = 1;
   */
  VCS = 1,

  /**
   * Issue, defect tracking system, or an Application Lifecycle Management (ALM) system
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER = 2;
   */
  ISSUE_TRACKER = 2,

  /**
   * Website
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_WEBSITE = 3;
   */
  WEBSITE = 3,

  /**
   * Security advisories
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_ADVISORIES = 4;
   */
  ADVISORIES = 4,

  /**
   * Bill-of-material document (CycloneDX, SPDX, SWID, etc)
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_BOM = 5;
   */
  BOM = 5,

  /**
   * Mailing list or discussion group
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_MAILING_LIST = 6;
   */
  MAILING_LIST = 6,

  /**
   * Social media account
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_SOCIAL = 7;
   */
  SOCIAL = 7,

  /**
   * Real-time chat platform
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_CHAT = 8;
   */
  CHAT = 8,

  /**
   * Documentation, guides, or how-to instructions
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_DOCUMENTATION = 9;
   */
  DOCUMENTATION = 9,

  /**
   * Community or commercial support
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_SUPPORT = 10;
   */
  SUPPORT = 10,

  /**
   * Direct or repository download location
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_DISTRIBUTION = 11;
   */
  DISTRIBUTION = 11,

  /**
   * The URL to the license file. If a license URL has been defined in the license node, it should also be defined as an external reference for completeness
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_LICENSE = 12;
   */
  LICENSE = 12,

  /**
   * Build-system specific meta file (i.e. pom.xml, package.json, .nuspec, etc)
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_BUILD_META = 13;
   */
  BUILD_META = 13,

  /**
   * URL to an automated build system
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM = 14;
   */
  BUILD_SYSTEM = 14,

  /**
   * Specifies a way to contact the maintainer, supplier, or provider in the event of a security incident. Common URIs include links to a disclosure procedure, a mailto (RFC-2368) that specifies an email address, a tel (RFC-3966) that specifies a phone number, or dns (RFC-4501) that specifies the records containing DNS Security TXT.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_SECURITY_CONTACT = 15;
   */
  SECURITY_CONTACT = 15,

  /**
   * Human or machine-readable statements containing facts, evidence, or testimony
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_ATTESTATION = 16;
   */
  ATTESTATION = 16,

  /**
   * An enumeration of identified weaknesses, threats, and countermeasures, dataflow diagram (DFD), attack tree, and other supporting documentation in human-readable or machine-readable format
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_THREAT_MODEL = 17;
   */
  THREAT_MODEL = 17,

  /**
   * The defined assumptions, goals, and capabilities of an adversary.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_ADVERSARY_MODEL = 18;
   */
  ADVERSARY_MODEL = 18,

  /**
   * Identifies and analyzes the potential of future events that may negatively impact individuals, assets, and/or the environment. Risk assessments may also include judgments on the tolerability of each risk.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_RISK_ASSESSMENT = 19;
   */
  RISK_ASSESSMENT = 19,

  /**
   * The location where a component was published. This is often the same as "distribution" but may also include specialized publishing processes that act as an intermediary
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_DISTRIBUTION_INTAKE = 20;
   */
  DISTRIBUTION_INTAKE = 20,

  /**
   * A Vulnerability Disclosure Report (VDR) which asserts the known and previously unknown vulnerabilities that affect a component, service, or product including the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on a component, service, or product
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_VULNERABILITY_ASSERTION = 21;
   */
  VULNERABILITY_ASSERTION = 21,

  /**
   * A Vulnerability Exploitability eXchange (VEX) asserts the known vulnerabilities that do not affect a product, product family, or organization, and optionally, the ones that do. The VEX should include the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on the product, product family, or organization
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_EXPLOITABILITY_STATEMENT = 22;
   */
  EXPLOITABILITY_STATEMENT = 22,

  /**
   * Results from an authorized simulated cyberattack on a component or service, otherwise known as a penetration test
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_PENTEST_REPORT = 23;
   */
  PENTEST_REPORT = 23,

  /**
   * SARIF or proprietary machine or human-readable report for which static analysis has identified code quality, security, and other potential issues with the source code
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_STATIC_ANALYSIS_REPORT = 24;
   */
  STATIC_ANALYSIS_REPORT = 24,

  /**
   * Dynamic analysis report that has identified issues such as vulnerabilities and misconfigurations
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_DYNAMIC_ANALYSIS_REPORT = 25;
   */
  DYNAMIC_ANALYSIS_REPORT = 25,

  /**
   * Report generated by analyzing the call stack of a running application
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_RUNTIME_ANALYSIS_REPORT = 26;
   */
  RUNTIME_ANALYSIS_REPORT = 26,

  /**
   * Report generated by Software Composition Analysis (SCA), container analysis, or other forms of component analysis
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_COMPONENT_ANALYSIS_REPORT = 27;
   */
  COMPONENT_ANALYSIS_REPORT = 27,

  /**
   * Report containing a formal assessment of an organization, business unit, or team against a maturity model
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_MATURITY_REPORT = 28;
   */
  MATURITY_REPORT = 28,

  /**
   * Industry, regulatory, or other certification from an accredited (if applicable) certification body
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_CERTIFICATION_REPORT = 29;
   */
  CERTIFICATION_REPORT = 29,

  /**
   * Report or system in which quality metrics can be obtained
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_QUALITY_METRICS = 30;
   */
  QUALITY_METRICS = 30,

  /**
   * Code or configuration that defines and provisions virtualized infrastructure, commonly referred to as Infrastructure as Code (IaC)
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_CODIFIED_INFRASTRUCTURE = 31;
   */
  CODIFIED_INFRASTRUCTURE = 31,

  /**
   * A model card describes the intended uses of a machine learning model, potential limitations, biases, ethical considerations, training parameters, datasets used to train the model, performance metrics, and other relevant data useful for ML transparency.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_MODEL_CARD = 32;
   */
  MODEL_CARD = 32,

  /**
   * Plans of Action and Milestones (POAM) complement an "attestation" external reference. POAM is defined by NIST as a "document that identifies tasks needing to be accomplished. It details resources required to accomplish the elements of the plan, any milestones in meeting the tasks and scheduled completion dates for the milestones".
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_POAM = 33;
   */
  POAM = 33,

  /**
   * A record of events that occurred in a computer system or application, such as problems, errors, or information on current operations.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_LOG = 34;
   */
  LOG = 34,

  /**
   * Parameters or settings that may be used by other components or services.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_CONFIGURATION = 35;
   */
  CONFIGURATION = 35,

  /**
   * Information used to substantiate a claim.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_EVIDENCE = 36;
   */
  EVIDENCE = 36,

  /**
   * Describes how a component or service was manufactured or deployed.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_FORMULATION = 37;
   */
  FORMULATION = 37,

  /**
   * The location where the source code distributable can be obtained. This is often an archive format such as zip or tar.gz. The source-distribution type complements the use of the version control (vcs) type.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_SOURCE_DISTRIBUTION = 38;
   */
  SOURCE_DISTRIBUTION = 38,

  /**
   * An e-signature is commonly a scanned representation of a written signature or a stylized script of the person's name.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_ELECTRONIC_SIGNATURE = 39;
   */
  ELECTRONIC_SIGNATURE = 39,

  /**
   * A signature that leverages cryptography, typically public/private key pairs, which provides strong authenticity verification.
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_DIGITAL_SIGNATURE = 40;
   */
  DIGITAL_SIGNATURE = 40,

  /**
   * Document that complies with RFC-9116 (A File Format to Aid in Security Vulnerability Disclosure)
   *
   * @generated from enum value: EXTERNAL_REFERENCE_TYPE_RFC_9116 = 41;
   */
  RFC_9116 = 41,
}
// Retrieve enum metadata with: proto3.getEnumType(ExternalReferenceType)
proto3.util.setEnumType(ExternalReferenceType, "cyclonedx.v1_6.ExternalReferenceType", [
  { no: 0, name: "EXTERNAL_REFERENCE_TYPE_OTHER" },
  { no: 1, name: "EXTERNAL_REFERENCE_TYPE_VCS" },
  { no: 2, name: "EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER" },
  { no: 3, name: "EXTERNAL_REFERENCE_TYPE_WEBSITE" },
  { no: 4, name: "EXTERNAL_REFERENCE_TYPE_ADVISORIES" },
  { no: 5, name: "EXTERNAL_REFERENCE_TYPE_BOM" },
  { no: 6, name: "EXTERNAL_REFERENCE_TYPE_MAILING_LIST" },
  { no: 7, name: "EXTERNAL_REFERENCE_TYPE_SOCIAL" },
  { no: 8, name: "EXTERNAL_REFERENCE_TYPE_CHAT" },
  { no: 9, name: "EXTERNAL_REFERENCE_TYPE_DOCUMENTATION" },
  { no: 10, name: "EXTERNAL_REFERENCE_TYPE_SUPPORT" },
  { no: 11, name: "EXTERNAL_REFERENCE_TYPE_DISTRIBUTION" },
  { no: 12, name: "EXTERNAL_REFERENCE_TYPE_LICENSE" },
  { no: 13, name: "EXTERNAL_REFERENCE_TYPE_BUILD_META" },
  { no: 14, name: "EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM" },
  { no: 15, name: "EXTERNAL_REFERENCE_TYPE_SECURITY_CONTACT" },
  { no: 16, name: "EXTERNAL_REFERENCE_TYPE_ATTESTATION" },
  { no: 17, name: "EXTERNAL_REFERENCE_TYPE_THREAT_MODEL" },
  { no: 18, name: "EXTERNAL_REFERENCE_TYPE_ADVERSARY_MODEL" },
  { no: 19, name: "EXTERNAL_REFERENCE_TYPE_RISK_ASSESSMENT" },
  { no: 20, name: "EXTERNAL_REFERENCE_TYPE_DISTRIBUTION_INTAKE" },
  { no: 21, name: "EXTERNAL_REFERENCE_TYPE_VULNERABILITY_ASSERTION" },
  { no: 22, name: "EXTERNAL_REFERENCE_TYPE_EXPLOITABILITY_STATEMENT" },
  { no: 23, name: "EXTERNAL_REFERENCE_TYPE_PENTEST_REPORT" },
  { no: 24, name: "EXTERNAL_REFERENCE_TYPE_STATIC_ANALYSIS_REPORT" },
  { no: 25, name: "EXTERNAL_REFERENCE_TYPE_DYNAMIC_ANALYSIS_REPORT" },
  { no: 26, name: "EXTERNAL_REFERENCE_TYPE_RUNTIME_ANALYSIS_REPORT" },
  { no: 27, name: "EXTERNAL_REFERENCE_TYPE_COMPONENT_ANALYSIS_REPORT" },
  { no: 28, name: "EXTERNAL_REFERENCE_TYPE_MATURITY_REPORT" },
  { no: 29, name: "EXTERNAL_REFERENCE_TYPE_CERTIFICATION_REPORT" },
  { no: 30, name: "EXTERNAL_REFERENCE_TYPE_QUALITY_METRICS" },
  { no: 31, name: "EXTERNAL_REFERENCE_TYPE_CODIFIED_INFRASTRUCTURE" },
  { no: 32, name: "EXTERNAL_REFERENCE_TYPE_MODEL_CARD" },
  { no: 33, name: "EXTERNAL_REFERENCE_TYPE_POAM" },
  { no: 34, name: "EXTERNAL_REFERENCE_TYPE_LOG" },
  { no: 35, name: "EXTERNAL_REFERENCE_TYPE_CONFIGURATION" },
  { no: 36, name: "EXTERNAL_REFERENCE_TYPE_EVIDENCE" },
  { no: 37, name: "EXTERNAL_REFERENCE_TYPE_FORMULATION" },
  { no: 38, name: "EXTERNAL_REFERENCE_TYPE_SOURCE_DISTRIBUTION" },
  { no: 39, name: "EXTERNAL_REFERENCE_TYPE_ELECTRONIC_SIGNATURE" },
  { no: 40, name: "EXTERNAL_REFERENCE_TYPE_DIGITAL_SIGNATURE" },
  { no: 41, name: "EXTERNAL_REFERENCE_TYPE_RFC_9116" },
]);

/**
 * @generated from enum cyclonedx.v1_6.HashAlg
 */
export enum HashAlg {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: HASH_ALG_NULL = 0;
   */
  NULL = 0,

  /**
   * @generated from enum value: HASH_ALG_MD_5 = 1;
   */
  MD_5 = 1,

  /**
   * @generated from enum value: HASH_ALG_SHA_1 = 2;
   */
  SHA_1 = 2,

  /**
   * @generated from enum value: HASH_ALG_SHA_256 = 3;
   */
  SHA_256 = 3,

  /**
   * @generated from enum value: HASH_ALG_SHA_384 = 4;
   */
  SHA_384 = 4,

  /**
   * @generated from enum value: HASH_ALG_SHA_512 = 5;
   */
  SHA_512 = 5,

  /**
   * @generated from enum value: HASH_ALG_SHA_3_256 = 6;
   */
  SHA_3_256 = 6,

  /**
   * @generated from enum value: HASH_ALG_SHA_3_384 = 7;
   */
  SHA_3_384 = 7,

  /**
   * @generated from enum value: HASH_ALG_SHA_3_512 = 8;
   */
  SHA_3_512 = 8,

  /**
   * @generated from enum value: HASH_ALG_BLAKE_2_B_256 = 9;
   */
  BLAKE_2_B_256 = 9,

  /**
   * @generated from enum value: HASH_ALG_BLAKE_2_B_384 = 10;
   */
  BLAKE_2_B_384 = 10,

  /**
   * @generated from enum value: HASH_ALG_BLAKE_2_B_512 = 11;
   */
  BLAKE_2_B_512 = 11,

  /**
   * @generated from enum value: HASH_ALG_BLAKE_3 = 12;
   */
  BLAKE_3 = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(HashAlg)
proto3.util.setEnumType(HashAlg, "cyclonedx.v1_6.HashAlg", [
  { no: 0, name: "HASH_ALG_NULL" },
  { no: 1, name: "HASH_ALG_MD_5" },
  { no: 2, name: "HASH_ALG_SHA_1" },
  { no: 3, name: "HASH_ALG_SHA_256" },
  { no: 4, name: "HASH_ALG_SHA_384" },
  { no: 5, name: "HASH_ALG_SHA_512" },
  { no: 6, name: "HASH_ALG_SHA_3_256" },
  { no: 7, name: "HASH_ALG_SHA_3_384" },
  { no: 8, name: "HASH_ALG_SHA_3_512" },
  { no: 9, name: "HASH_ALG_BLAKE_2_B_256" },
  { no: 10, name: "HASH_ALG_BLAKE_2_B_384" },
  { no: 11, name: "HASH_ALG_BLAKE_2_B_512" },
  { no: 12, name: "HASH_ALG_BLAKE_3" },
]);

/**
 * @generated from enum cyclonedx.v1_6.IssueClassification
 */
export enum IssueClassification {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: ISSUE_CLASSIFICATION_NULL = 0;
   */
  NULL = 0,

  /**
   * A fault, flaw, or bug in software
   *
   * @generated from enum value: ISSUE_CLASSIFICATION_DEFECT = 1;
   */
  DEFECT = 1,

  /**
   * A new feature or behavior in software
   *
   * @generated from enum value: ISSUE_CLASSIFICATION_ENHANCEMENT = 2;
   */
  ENHANCEMENT = 2,

  /**
   * A special type of defect which impacts security
   *
   * @generated from enum value: ISSUE_CLASSIFICATION_SECURITY = 3;
   */
  SECURITY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(IssueClassification)
proto3.util.setEnumType(IssueClassification, "cyclonedx.v1_6.IssueClassification", [
  { no: 0, name: "ISSUE_CLASSIFICATION_NULL" },
  { no: 1, name: "ISSUE_CLASSIFICATION_DEFECT" },
  { no: 2, name: "ISSUE_CLASSIFICATION_ENHANCEMENT" },
  { no: 3, name: "ISSUE_CLASSIFICATION_SECURITY" },
]);

/**
 * Declared licenses and concluded licenses represent two different stages in the licensing process within software development. Declared licenses refer to the initial intention of the software authors regarding the licensing terms under which their code is released. On the other hand, concluded licenses are the result of a comprehensive analysis of the project's codebase to identify and confirm the actual licenses of the components used, which may differ from the initially declared licenses. While declared licenses provide an upfront indication of the licensing intentions, concluded licenses offer a more thorough understanding of the actual licensing within a project, facilitating proper compliance and risk management. Observed licenses are defined in `@.evidence.licenses`. Observed licenses form the evidence necessary to substantiate a concluded license.
 *
 * @generated from enum cyclonedx.v1_6.LicenseAcknowledgementEnumeration
 */
export enum LicenseAcknowledgementEnumeration {
  /**
   * The license acknowledgement is not specified.
   *
   * @generated from enum value: LICENSE_ACKNOWLEDGEMENT_ENUMERATION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Declared licenses represent the initial intentions of authors regarding the licensing terms of their code.
   *
   * @generated from enum value: LICENSE_ACKNOWLEDGEMENT_ENUMERATION_DECLARED = 1;
   */
  DECLARED = 1,

  /**
   * Concluded licenses are verified and confirmed.
   *
   * @generated from enum value: LICENSE_ACKNOWLEDGEMENT_ENUMERATION_CONCLUDED = 2;
   */
  CONCLUDED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LicenseAcknowledgementEnumeration)
proto3.util.setEnumType(LicenseAcknowledgementEnumeration, "cyclonedx.v1_6.LicenseAcknowledgementEnumeration", [
  { no: 0, name: "LICENSE_ACKNOWLEDGEMENT_ENUMERATION_UNSPECIFIED" },
  { no: 1, name: "LICENSE_ACKNOWLEDGEMENT_ENUMERATION_DECLARED" },
  { no: 2, name: "LICENSE_ACKNOWLEDGEMENT_ENUMERATION_CONCLUDED" },
]);

/**
 * buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "LICENSING_TYPE_ENUM_"
 *
 * @generated from enum cyclonedx.v1_6.LicensingTypeEnum
 */
export enum LicensingTypeEnum {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: LICENSING_TYPE_NULL = 0;
   */
  LICENSING_TYPE_NULL = 0,

  /**
   * A license that grants use of software solely for the purpose of education or research.
   *
   * @generated from enum value: LICENSING_TYPE_ACADEMIC = 1;
   */
  LICENSING_TYPE_ACADEMIC = 1,

  /**
   * A license covering use of software embedded in a specific piece of hardware.
   *
   * @generated from enum value: LICENSING_TYPE_APPLIANCE = 2;
   */
  LICENSING_TYPE_APPLIANCE = 2,

  /**
   * A Client Access License (CAL) allows client computers to access services provided by server software.
   *
   * @generated from enum value: LICENSING_TYPE_CLIENT_ACCESS = 3;
   */
  LICENSING_TYPE_CLIENT_ACCESS = 3,

  /**
   * A Concurrent User license (aka floating license) limits the number of licenses for a software application and licenses are shared among a larger number of users.
   *
   * @generated from enum value: LICENSING_TYPE_CONCURRENT_USER = 4;
   */
  LICENSING_TYPE_CONCURRENT_USER = 4,

  /**
   * A license where the core of a computer's processor is assigned a specific number of points.
   *
   * @generated from enum value: LICENSING_TYPE_CORE_POINTS = 5;
   */
  LICENSING_TYPE_CORE_POINTS = 5,

  /**
   * A license for which consumption is measured by non-standard metrics.
   *
   * @generated from enum value: LICENSING_TYPE_CUSTOM_METRIC = 6;
   */
  LICENSING_TYPE_CUSTOM_METRIC = 6,

  /**
   * A license that covers a defined number of installations on computers and other types of devices.
   *
   * @generated from enum value: LICENSING_TYPE_DEVICE = 7;
   */
  LICENSING_TYPE_DEVICE = 7,

  /**
   * A license that grants permission to install and use software for trial purposes.
   *
   * @generated from enum value: LICENSING_TYPE_EVALUATION = 8;
   */
  LICENSING_TYPE_EVALUATION = 8,

  /**
   * A license that grants access to the software to one or more pre-defined users.
   *
   * @generated from enum value: LICENSING_TYPE_NAMED_USER = 9;
   */
  LICENSING_TYPE_NAMED_USER = 9,

  /**
   * A license that grants access to the software on one or more pre-defined computers or devices.
   *
   * @generated from enum value: LICENSING_TYPE_NODE_LOCKED = 10;
   */
  LICENSING_TYPE_NODE_LOCKED = 10,

  /**
   * An Original Equipment Manufacturer license that is delivered with hardware, cannot be transferred to other hardware, and is valid for the life of the hardware.
   *
   * @generated from enum value: LICENSING_TYPE_OEM = 11;
   */
  LICENSING_TYPE_OEM = 11,

  /**
   * A license where the software is sold on a one-time basis and the licensee can use a copy of the software indefinitely.
   *
   * @generated from enum value: LICENSING_TYPE_PERPETUAL = 12;
   */
  LICENSING_TYPE_PERPETUAL = 12,

  /**
   * A license where each installation consumes points per processor.
   *
   * @generated from enum value: LICENSING_TYPE_PROCESSOR_POINTS = 13;
   */
  LICENSING_TYPE_PROCESSOR_POINTS = 13,

  /**
   * A license where the licensee pays a fee to use the software or service.
   *
   * @generated from enum value: LICENSING_TYPE_SUBSCRIPTION = 14;
   */
  LICENSING_TYPE_SUBSCRIPTION = 14,

  /**
   * A license that grants access to the software or service by a specified number of users.
   *
   * @generated from enum value: LICENSING_TYPE_USER = 15;
   */
  LICENSING_TYPE_USER = 15,

  /**
   * Another license type.
   *
   * @generated from enum value: LICENSING_TYPE_OTHER = 16;
   */
  LICENSING_TYPE_OTHER = 16,
}
// Retrieve enum metadata with: proto3.getEnumType(LicensingTypeEnum)
proto3.util.setEnumType(LicensingTypeEnum, "cyclonedx.v1_6.LicensingTypeEnum", [
  { no: 0, name: "LICENSING_TYPE_NULL" },
  { no: 1, name: "LICENSING_TYPE_ACADEMIC" },
  { no: 2, name: "LICENSING_TYPE_APPLIANCE" },
  { no: 3, name: "LICENSING_TYPE_CLIENT_ACCESS" },
  { no: 4, name: "LICENSING_TYPE_CONCURRENT_USER" },
  { no: 5, name: "LICENSING_TYPE_CORE_POINTS" },
  { no: 6, name: "LICENSING_TYPE_CUSTOM_METRIC" },
  { no: 7, name: "LICENSING_TYPE_DEVICE" },
  { no: 8, name: "LICENSING_TYPE_EVALUATION" },
  { no: 9, name: "LICENSING_TYPE_NAMED_USER" },
  { no: 10, name: "LICENSING_TYPE_NODE_LOCKED" },
  { no: 11, name: "LICENSING_TYPE_OEM" },
  { no: 12, name: "LICENSING_TYPE_PERPETUAL" },
  { no: 13, name: "LICENSING_TYPE_PROCESSOR_POINTS" },
  { no: 14, name: "LICENSING_TYPE_SUBSCRIPTION" },
  { no: 15, name: "LICENSING_TYPE_USER" },
  { no: 16, name: "LICENSING_TYPE_OTHER" },
]);

/**
 * @generated from enum cyclonedx.v1_6.LifecyclePhase
 */
export enum LifecyclePhase {
  /**
   * BOM produced early in the development lifecycle containing an inventory of components and services that are proposed or planned to be used. The inventory may need to be procured, retrieved, or resourced prior to use.
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
   *
   * @generated from enum value: LIFECYCLE_PHASE_DESIGN = 0;
   */
  DESIGN = 0,

  /**
   * BOM consists of information obtained prior to a build process and may contain source files, development artifacts, and manifests. The inventory may need to be resolved and retrieved prior to use.
   *
   * @generated from enum value: LIFECYCLE_PHASE_PRE_BUILD = 1;
   */
  PRE_BUILD = 1,

  /**
   * BOM consisting of information obtained during a build process where component inventory is available for use. The precise versions of resolved components are usually available at this time as well as the provenance of where the components were retrieved from.
   *
   * @generated from enum value: LIFECYCLE_PHASE_BUILD = 2;
   */
  BUILD = 2,

  /**
   * BOM consisting of information obtained after a build process has completed and the resulting components(s) are available for further analysis. Built components may exist as the result of a CI/CD process, may have been installed or deployed to a system or device, and may need to be retrieved or extracted from the system or device.
   *
   * @generated from enum value: LIFECYCLE_PHASE_POST_BUILD = 3;
   */
  POST_BUILD = 3,

  /**
   * BOM produced that represents inventory that is running and operational. This may include staging or production environments and will generally encompass multiple SBOMs describing the applications and operating system, along with HBOMs describing the hardware that makes up the system. Operations Bill of Materials (OBOM) can provide full-stack inventory of runtime environments, configurations, and additional dependencies.
   *
   * @generated from enum value: LIFECYCLE_PHASE_OPERATIONS = 4;
   */
  OPERATIONS = 4,

  /**
   * BOM consisting of information observed through network discovery providing point-in-time enumeration of embedded, on-premise, and cloud-native services such as server applications, connected devices, microservices, and serverless functions.
   *
   * @generated from enum value: LIFECYCLE_PHASE_DISCOVERY = 5;
   */
  DISCOVERY = 5,

  /**
   * BOM containing inventory that will be, or has been retired from operations.
   *
   * @generated from enum value: LIFECYCLE_PHASE_DECOMMISSION = 6;
   */
  DECOMMISSION = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(LifecyclePhase)
proto3.util.setEnumType(LifecyclePhase, "cyclonedx.v1_6.LifecyclePhase", [
  { no: 0, name: "LIFECYCLE_PHASE_DESIGN" },
  { no: 1, name: "LIFECYCLE_PHASE_PRE_BUILD" },
  { no: 2, name: "LIFECYCLE_PHASE_BUILD" },
  { no: 3, name: "LIFECYCLE_PHASE_POST_BUILD" },
  { no: 4, name: "LIFECYCLE_PHASE_OPERATIONS" },
  { no: 5, name: "LIFECYCLE_PHASE_DISCOVERY" },
  { no: 6, name: "LIFECYCLE_PHASE_DECOMMISSION" },
]);

/**
 * @generated from enum cyclonedx.v1_6.PatchClassification
 */
export enum PatchClassification {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: PATCH_CLASSIFICATION_NULL = 0;
   */
  NULL = 0,

  /**
   * A patch which is not developed by the creators or maintainers of the software being patched. Refer to https://en.wikipedia.org/wiki/Unofficial_patch
   *
   * @generated from enum value: PATCH_CLASSIFICATION_UNOFFICIAL = 1;
   */
  UNOFFICIAL = 1,

  /**
   * A patch which dynamically modifies runtime behavior. Refer to https://en.wikipedia.org/wiki/Monkey_patch
   *
   * @generated from enum value: PATCH_CLASSIFICATION_MONKEY = 2;
   */
  MONKEY = 2,

  /**
   * A patch which takes code from a newer version of software and applies it to older versions of the same software. Refer to https://en.wikipedia.org/wiki/Backporting
   *
   * @generated from enum value: PATCH_CLASSIFICATION_BACKPORT = 3;
   */
  BACKPORT = 3,

  /**
   * A patch created by selectively applying commits from other versions or branches of the same software.
   *
   * @generated from enum value: PATCH_CLASSIFICATION_CHERRY_PICK = 4;
   */
  CHERRY_PICK = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(PatchClassification)
proto3.util.setEnumType(PatchClassification, "cyclonedx.v1_6.PatchClassification", [
  { no: 0, name: "PATCH_CLASSIFICATION_NULL" },
  { no: 1, name: "PATCH_CLASSIFICATION_UNOFFICIAL" },
  { no: 2, name: "PATCH_CLASSIFICATION_MONKEY" },
  { no: 3, name: "PATCH_CLASSIFICATION_BACKPORT" },
  { no: 4, name: "PATCH_CLASSIFICATION_CHERRY_PICK" },
]);

/**
 * @generated from enum cyclonedx.v1_6.Scope
 */
export enum Scope {
  /**
   * Default
   *
   * @generated from enum value: SCOPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The component is required for runtime
   *
   * @generated from enum value: SCOPE_REQUIRED = 1;
   */
  REQUIRED = 1,

  /**
   * The component is optional at runtime. Optional components are components that are not capable of being called due to them not being installed or otherwise accessible by any means. Components that are installed but, due to configuration or other restrictions, are prohibited from being called must be scoped as 'required'.
   *
   * @generated from enum value: SCOPE_OPTIONAL = 2;
   */
  OPTIONAL = 2,

  /**
   * Components that are excluded provide the ability to document component usage for test and other non-runtime purposes. Excluded components are not reachable within a call graph at runtime.
   *
   * @generated from enum value: SCOPE_EXCLUDED = 3;
   */
  EXCLUDED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Scope)
proto3.util.setEnumType(Scope, "cyclonedx.v1_6.Scope", [
  { no: 0, name: "SCOPE_UNSPECIFIED" },
  { no: 1, name: "SCOPE_REQUIRED" },
  { no: 2, name: "SCOPE_OPTIONAL" },
  { no: 3, name: "SCOPE_EXCLUDED" },
]);

/**
 * @generated from enum cyclonedx.v1_6.Aggregate
 */
export enum Aggregate {
  /**
   * The relationship completeness is not specified.
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `not specified` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: AGGREGATE_NOT_SPECIFIED = 0;
   */
  NOT_SPECIFIED = 0,

  /**
   * The relationship is complete. No further relationships including constituent components, services, or dependencies are known to exist.
   *
   * @generated from enum value: AGGREGATE_COMPLETE = 1;
   */
  COMPLETE = 1,

  /**
   * The relationship is incomplete. Additional relationships exist and may include constituent components, services, or dependencies.
   *
   * @generated from enum value: AGGREGATE_INCOMPLETE = 2;
   */
  INCOMPLETE = 2,

  /**
   * The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented.
   *
   * @generated from enum value: AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY = 3;
   */
  INCOMPLETE_FIRST_PARTY_ONLY = 3,

  /**
   * The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented.
   *
   * @generated from enum value: AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY = 4;
   */
  INCOMPLETE_THIRD_PARTY_ONLY = 4,

  /**
   * The relationship may be complete or incomplete. This usually signifies a 'best-effort' to obtain constituent components, services, or dependencies but the completeness is inconclusive.
   *
   * @generated from enum value: AGGREGATE_UNKNOWN = 5;
   */
  UNKNOWN = 5,

  /**
   * The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.
   *
   * @generated from enum value: AGGREGATE_INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY = 6;
   */
  INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY = 6,

  /**
   * The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are opensource.
   *
   * @generated from enum value: AGGREGATE_INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY = 7;
   */
  INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY = 7,

  /**
   * The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.
   *
   * @generated from enum value: AGGREGATE_INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY = 8;
   */
  INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY = 8,

  /**
   * The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are opensource.
   *
   * @generated from enum value: AGGREGATE_INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY = 9;
   */
  INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(Aggregate)
proto3.util.setEnumType(Aggregate, "cyclonedx.v1_6.Aggregate", [
  { no: 0, name: "AGGREGATE_NOT_SPECIFIED" },
  { no: 1, name: "AGGREGATE_COMPLETE" },
  { no: 2, name: "AGGREGATE_INCOMPLETE" },
  { no: 3, name: "AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY" },
  { no: 4, name: "AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY" },
  { no: 5, name: "AGGREGATE_UNKNOWN" },
  { no: 6, name: "AGGREGATE_INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY" },
  { no: 7, name: "AGGREGATE_INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY" },
  { no: 8, name: "AGGREGATE_INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY" },
  { no: 9, name: "AGGREGATE_INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY" },
]);

/**
 * buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "EVIDENCE_FIELD_TYPE_"
 *
 * @generated from enum cyclonedx.v1_6.EvidenceFieldType
 */
export enum EvidenceFieldType {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: EVIDENCE_FIELD_NULL = 0;
   */
  EVIDENCE_FIELD_NULL = 0,

  /**
   * @generated from enum value: EVIDENCE_FIELD_GROUP = 1;
   */
  EVIDENCE_FIELD_GROUP = 1,

  /**
   * @generated from enum value: EVIDENCE_FIELD_NAME = 2;
   */
  EVIDENCE_FIELD_NAME = 2,

  /**
   * @generated from enum value: EVIDENCE_FIELD_VERSION = 3;
   */
  EVIDENCE_FIELD_VERSION = 3,

  /**
   * @generated from enum value: EVIDENCE_FIELD_PURL = 4;
   */
  EVIDENCE_FIELD_PURL = 4,

  /**
   * @generated from enum value: EVIDENCE_FIELD_CPE = 5;
   */
  EVIDENCE_FIELD_CPE = 5,

  /**
   * @generated from enum value: EVIDENCE_FIELD_SWID = 6;
   */
  EVIDENCE_FIELD_SWID = 6,

  /**
   * @generated from enum value: EVIDENCE_FIELD_HASH = 7;
   */
  EVIDENCE_FIELD_HASH = 7,

  /**
   * @generated from enum value: EVIDENCE_FIELD_OMNIBOR_ID = 8;
   */
  EVIDENCE_FIELD_OMNIBOR_ID = 8,

  /**
   * @generated from enum value: EVIDENCE_FIELD_SWHID = 9;
   */
  EVIDENCE_FIELD_SWHID = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(EvidenceFieldType)
proto3.util.setEnumType(EvidenceFieldType, "cyclonedx.v1_6.EvidenceFieldType", [
  { no: 0, name: "EVIDENCE_FIELD_NULL" },
  { no: 1, name: "EVIDENCE_FIELD_GROUP" },
  { no: 2, name: "EVIDENCE_FIELD_NAME" },
  { no: 3, name: "EVIDENCE_FIELD_VERSION" },
  { no: 4, name: "EVIDENCE_FIELD_PURL" },
  { no: 5, name: "EVIDENCE_FIELD_CPE" },
  { no: 6, name: "EVIDENCE_FIELD_SWID" },
  { no: 7, name: "EVIDENCE_FIELD_HASH" },
  { no: 8, name: "EVIDENCE_FIELD_OMNIBOR_ID" },
  { no: 9, name: "EVIDENCE_FIELD_SWHID" },
]);

/**
 * @generated from enum cyclonedx.v1_6.EvidenceTechnique
 */
export enum EvidenceTechnique {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error, it shall be fixed with v2.0 of this very schema
   *
   * @generated from enum value: EVIDENCE_TECHNIQUE_SOURCE_CODE_ANALYSIS = 0;
   */
  SOURCE_CODE_ANALYSIS = 0,

  /**
   * @generated from enum value: EVIDENCE_TECHNIQUE_BINARY_ANALYSIS = 1;
   */
  BINARY_ANALYSIS = 1,

  /**
   * @generated from enum value: EVIDENCE_TECHNIQUE_MANIFEST_ANALYSIS = 2;
   */
  MANIFEST_ANALYSIS = 2,

  /**
   * @generated from enum value: EVIDENCE_TECHNIQUE_AST_FINGERPRINT = 3;
   */
  AST_FINGERPRINT = 3,

  /**
   * @generated from enum value: EVIDENCE_TECHNIQUE_HASH_COMPARISON = 4;
   */
  HASH_COMPARISON = 4,

  /**
   * @generated from enum value: EVIDENCE_TECHNIQUE_INSTRUMENTATION = 5;
   */
  INSTRUMENTATION = 5,

  /**
   * @generated from enum value: EVIDENCE_TECHNIQUE_DYNAMIC_ANALYSIS = 6;
   */
  DYNAMIC_ANALYSIS = 6,

  /**
   * @generated from enum value: EVIDENCE_TECHNIQUE_FILENAME = 7;
   */
  FILENAME = 7,

  /**
   * @generated from enum value: EVIDENCE_TECHNIQUE_ATTESTATION = 8;
   */
  ATTESTATION = 8,

  /**
   * @generated from enum value: EVIDENCE_TECHNIQUE_OTHER = 9;
   */
  OTHER = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(EvidenceTechnique)
proto3.util.setEnumType(EvidenceTechnique, "cyclonedx.v1_6.EvidenceTechnique", [
  { no: 0, name: "EVIDENCE_TECHNIQUE_SOURCE_CODE_ANALYSIS" },
  { no: 1, name: "EVIDENCE_TECHNIQUE_BINARY_ANALYSIS" },
  { no: 2, name: "EVIDENCE_TECHNIQUE_MANIFEST_ANALYSIS" },
  { no: 3, name: "EVIDENCE_TECHNIQUE_AST_FINGERPRINT" },
  { no: 4, name: "EVIDENCE_TECHNIQUE_HASH_COMPARISON" },
  { no: 5, name: "EVIDENCE_TECHNIQUE_INSTRUMENTATION" },
  { no: 6, name: "EVIDENCE_TECHNIQUE_DYNAMIC_ANALYSIS" },
  { no: 7, name: "EVIDENCE_TECHNIQUE_FILENAME" },
  { no: 8, name: "EVIDENCE_TECHNIQUE_ATTESTATION" },
  { no: 9, name: "EVIDENCE_TECHNIQUE_OTHER" },
]);

/**
 * @generated from enum cyclonedx.v1_6.Severity
 */
export enum Severity {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `unknown` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: SEVERITY_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: SEVERITY_CRITICAL = 1;
   */
  CRITICAL = 1,

  /**
   * @generated from enum value: SEVERITY_HIGH = 2;
   */
  HIGH = 2,

  /**
   * @generated from enum value: SEVERITY_MEDIUM = 3;
   */
  MEDIUM = 3,

  /**
   * @generated from enum value: SEVERITY_LOW = 4;
   */
  LOW = 4,

  /**
   * @generated from enum value: SEVERITY_INFO = 5;
   */
  INFO = 5,

  /**
   * @generated from enum value: SEVERITY_NONE = 6;
   */
  NONE = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(Severity)
proto3.util.setEnumType(Severity, "cyclonedx.v1_6.Severity", [
  { no: 0, name: "SEVERITY_UNKNOWN" },
  { no: 1, name: "SEVERITY_CRITICAL" },
  { no: 2, name: "SEVERITY_HIGH" },
  { no: 3, name: "SEVERITY_MEDIUM" },
  { no: 4, name: "SEVERITY_LOW" },
  { no: 5, name: "SEVERITY_INFO" },
  { no: 6, name: "SEVERITY_NONE" },
]);

/**
 * @generated from enum cyclonedx.v1_6.ScoreMethod
 */
export enum ScoreMethod {
  /**
   * An undefined score method
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: SCORE_METHOD_NULL = 0;
   */
  NULL = 0,

  /**
   * Common Vulnerability Scoring System v2 - https://www.first.org/cvss/v2/
   *
   * @generated from enum value: SCORE_METHOD_CVSSV2 = 1;
   */
  CVSSV2 = 1,

  /**
   * Common Vulnerability Scoring System v3 - https://www.first.org/cvss/v3-0/
   *
   * @generated from enum value: SCORE_METHOD_CVSSV3 = 2;
   */
  CVSSV3 = 2,

  /**
   * Common Vulnerability Scoring System v3.1 - https://www.first.org/cvss/v3-1/
   *
   * @generated from enum value: SCORE_METHOD_CVSSV31 = 3;
   */
  CVSSV31 = 3,

  /**
   * OWASP Risk Rating Methodology - https://owasp.org/www-community/OWASP_Risk_Rating_Methodology
   *
   * @generated from enum value: SCORE_METHOD_OWASP = 4;
   */
  OWASP = 4,

  /**
   * Other scoring method
   *
   * @generated from enum value: SCORE_METHOD_OTHER = 5;
   */
  OTHER = 5,

  /**
   * Common Vulnerability Scoring System v4.0 - https://www.first.org/cvss/v4-0/
   *
   * @generated from enum value: SCORE_METHOD_CVSSV4 = 6;
   */
  CVSSV4 = 6,

  /**
   * Stakeholder Specific Vulnerability Categorization (all versions) - https://github.com/CERTCC/SSVC
   *
   * @generated from enum value: SCORE_METHOD_SSVC = 7;
   */
  SSVC = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(ScoreMethod)
proto3.util.setEnumType(ScoreMethod, "cyclonedx.v1_6.ScoreMethod", [
  { no: 0, name: "SCORE_METHOD_NULL" },
  { no: 1, name: "SCORE_METHOD_CVSSV2" },
  { no: 2, name: "SCORE_METHOD_CVSSV3" },
  { no: 3, name: "SCORE_METHOD_CVSSV31" },
  { no: 4, name: "SCORE_METHOD_OWASP" },
  { no: 5, name: "SCORE_METHOD_OTHER" },
  { no: 6, name: "SCORE_METHOD_CVSSV4" },
  { no: 7, name: "SCORE_METHOD_SSVC" },
]);

/**
 * @generated from enum cyclonedx.v1_6.ImpactAnalysisState
 */
export enum ImpactAnalysisState {
  /**
   * An undefined impact analysis state
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: IMPACT_ANALYSIS_STATE_NULL = 0;
   */
  NULL = 0,

  /**
   * The vulnerability has been remediated.
   *
   * @generated from enum value: IMPACT_ANALYSIS_STATE_RESOLVED = 1;
   */
  RESOLVED = 1,

  /**
   * The vulnerability has been remediated, and evidence of the changes is provided in the affected components pedigree containing verifiable commit history and/or diff(s).
   *
   * @generated from enum value: IMPACT_ANALYSIS_STATE_RESOLVED_WITH_PEDIGREE = 2;
   */
  RESOLVED_WITH_PEDIGREE = 2,

  /**
   * The vulnerability may be directly or indirectly exploitable.
   *
   * @generated from enum value: IMPACT_ANALYSIS_STATE_EXPLOITABLE = 3;
   */
  EXPLOITABLE = 3,

  /**
   * The vulnerability is being investigated.
   *
   * @generated from enum value: IMPACT_ANALYSIS_STATE_IN_TRIAGE = 4;
   */
  IN_TRIAGE = 4,

  /**
   * The vulnerability is not specific to the component or service and was falsely identified or associated.
   *
   * @generated from enum value: IMPACT_ANALYSIS_STATE_FALSE_POSITIVE = 5;
   */
  FALSE_POSITIVE = 5,

  /**
   * The component or service is not affected by the vulnerability. Justification should be specified for all not_affected cases.
   *
   * @generated from enum value: IMPACT_ANALYSIS_STATE_NOT_AFFECTED = 6;
   */
  NOT_AFFECTED = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ImpactAnalysisState)
proto3.util.setEnumType(ImpactAnalysisState, "cyclonedx.v1_6.ImpactAnalysisState", [
  { no: 0, name: "IMPACT_ANALYSIS_STATE_NULL" },
  { no: 1, name: "IMPACT_ANALYSIS_STATE_RESOLVED" },
  { no: 2, name: "IMPACT_ANALYSIS_STATE_RESOLVED_WITH_PEDIGREE" },
  { no: 3, name: "IMPACT_ANALYSIS_STATE_EXPLOITABLE" },
  { no: 4, name: "IMPACT_ANALYSIS_STATE_IN_TRIAGE" },
  { no: 5, name: "IMPACT_ANALYSIS_STATE_FALSE_POSITIVE" },
  { no: 6, name: "IMPACT_ANALYSIS_STATE_NOT_AFFECTED" },
]);

/**
 * @generated from enum cyclonedx.v1_6.ImpactAnalysisJustification
 */
export enum ImpactAnalysisJustification {
  /**
   * An undefined impact analysis justification
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_NULL = 0;
   */
  NULL = 0,

  /**
   * The code has been removed or tree-shaked.
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_PRESENT = 1;
   */
  CODE_NOT_PRESENT = 1,

  /**
   * The vulnerable code is not invoked at runtime.
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_REACHABLE = 2;
   */
  CODE_NOT_REACHABLE = 2,

  /**
   * Exploitability requires a configurable option to be set/unset.
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_CONFIGURATION = 3;
   */
  REQUIRES_CONFIGURATION = 3,

  /**
   * Exploitability requires a dependency that is not present.
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_DEPENDENCY = 4;
   */
  REQUIRES_DEPENDENCY = 4,

  /**
   * Exploitability requires a certain environment which is not present.
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_ENVIRONMENT = 5;
   */
  REQUIRES_ENVIRONMENT = 5,

  /**
   * Exploitability requires a compiler flag to be set/unset.
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_COMPILER = 6;
   */
  PROTECTED_BY_COMPILER = 6,

  /**
   * Exploits are prevented at runtime.
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_RUNTIME = 7;
   */
  PROTECTED_AT_RUNTIME = 7,

  /**
   * Attacks are blocked at physical, logical, or network perimeter.
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_PERIMETER = 8;
   */
  PROTECTED_AT_PERIMETER = 8,

  /**
   * Preventative measures have been implemented that reduce the likelihood and/or impact of the vulnerability.
   *
   * @generated from enum value: IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_MITIGATING_CONTROL = 9;
   */
  PROTECTED_BY_MITIGATING_CONTROL = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(ImpactAnalysisJustification)
proto3.util.setEnumType(ImpactAnalysisJustification, "cyclonedx.v1_6.ImpactAnalysisJustification", [
  { no: 0, name: "IMPACT_ANALYSIS_JUSTIFICATION_NULL" },
  { no: 1, name: "IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_PRESENT" },
  { no: 2, name: "IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_REACHABLE" },
  { no: 3, name: "IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_CONFIGURATION" },
  { no: 4, name: "IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_DEPENDENCY" },
  { no: 5, name: "IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_ENVIRONMENT" },
  { no: 6, name: "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_COMPILER" },
  { no: 7, name: "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_RUNTIME" },
  { no: 8, name: "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_PERIMETER" },
  { no: 9, name: "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_MITIGATING_CONTROL" },
]);

/**
 * @generated from enum cyclonedx.v1_6.VulnerabilityResponse
 */
export enum VulnerabilityResponse {
  /**
   * unspecified value
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: VULNERABILITY_RESPONSE_NULL = 0;
   */
  NULL = 0,

  /**
   * @generated from enum value: VULNERABILITY_RESPONSE_CAN_NOT_FIX = 1;
   */
  CAN_NOT_FIX = 1,

  /**
   * @generated from enum value: VULNERABILITY_RESPONSE_WILL_NOT_FIX = 2;
   */
  WILL_NOT_FIX = 2,

  /**
   * @generated from enum value: VULNERABILITY_RESPONSE_UPDATE = 3;
   */
  UPDATE = 3,

  /**
   * @generated from enum value: VULNERABILITY_RESPONSE_ROLLBACK = 4;
   */
  ROLLBACK = 4,

  /**
   * @generated from enum value: VULNERABILITY_RESPONSE_WORKAROUND_AVAILABLE = 5;
   */
  WORKAROUND_AVAILABLE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(VulnerabilityResponse)
proto3.util.setEnumType(VulnerabilityResponse, "cyclonedx.v1_6.VulnerabilityResponse", [
  { no: 0, name: "VULNERABILITY_RESPONSE_NULL" },
  { no: 1, name: "VULNERABILITY_RESPONSE_CAN_NOT_FIX" },
  { no: 2, name: "VULNERABILITY_RESPONSE_WILL_NOT_FIX" },
  { no: 3, name: "VULNERABILITY_RESPONSE_UPDATE" },
  { no: 4, name: "VULNERABILITY_RESPONSE_ROLLBACK" },
  { no: 5, name: "VULNERABILITY_RESPONSE_WORKAROUND_AVAILABLE" },
]);

/**
 * The vulnerability status of a given version or range of versions of a product. The statuses 'affected' and 'unaffected' indicate that the version is affected or unaffected by the vulnerability. The status 'unknown' indicates that it is unknown or unspecified whether the given version is affected. There can be many reasons for an 'unknown' status, including that an investigation has not been undertaken or that a vendor has not disclosed the status.
 *
 * @generated from enum cyclonedx.v1_6.VulnerabilityAffectedStatus
 */
export enum VulnerabilityAffectedStatus {
  /**
   * It is unknown (or unspecified) whether the given version is affected.
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `unknown` is our fallback, doubling `unspecified`
   *
   * @generated from enum value: VULNERABILITY_AFFECTED_STATUS_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: VULNERABILITY_AFFECTED_STATUS_AFFECTED = 1;
   */
  AFFECTED = 1,

  /**
   * @generated from enum value: VULNERABILITY_AFFECTED_STATUS_NOT_AFFECTED = 2;
   */
  NOT_AFFECTED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(VulnerabilityAffectedStatus)
proto3.util.setEnumType(VulnerabilityAffectedStatus, "cyclonedx.v1_6.VulnerabilityAffectedStatus", [
  { no: 0, name: "VULNERABILITY_AFFECTED_STATUS_UNKNOWN" },
  { no: 1, name: "VULNERABILITY_AFFECTED_STATUS_AFFECTED" },
  { no: 2, name: "VULNERABILITY_AFFECTED_STATUS_NOT_AFFECTED" },
]);

/**
 * @generated from enum cyclonedx.v1_6.ModelParameterApproachType
 */
export enum ModelParameterApproachType {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error, it shall be fixed with v2.0 of this very schema
   * Supervised machine learning involves training an algorithm on labeled data to predict or classify new data based on the patterns learned from the labeled examples.
   *
   * @generated from enum value: MODEL_PARAMETER_APPROACH_TYPE_SUPERVISED = 0;
   */
  SUPERVISED = 0,

  /**
   * Unsupervised machine learning involves training algorithms on unlabeled data to discover patterns, structures, or relationships without explicit guidance, allowing the model to identify inherent structures or clusters within the data.
   *
   * @generated from enum value: MODEL_PARAMETER_APPROACH_TYPE_UNSUPERVISED = 1;
   */
  UNSUPERVISED = 1,

  /**
   * Reinforcement learning is a type of machine learning where an agent learns to make decisions by interacting with an environment to maximize cumulative rewards, through trial and error.
   *
   * @generated from enum value: MODEL_PARAMETER_APPROACH_TYPE_REINFORCED_LEARNING = 2;
   */
  REINFORCED_LEARNING = 2,

  /**
   * Semi-supervised machine learning utilizes a combination of labeled and unlabeled data during training to improve model performance, leveraging the benefits of both supervised and unsupervised learning techniques.
   *
   * @generated from enum value: MODEL_PARAMETER_APPROACH_TYPE_SEMI_SUPERVISED = 3;
   */
  SEMI_SUPERVISED = 3,

  /**
   * Self-supervised machine learning involves training models to predict parts of the input data from other parts of the same data, without requiring external labels, enabling learning from large amounts of unlabeled data.
   *
   * @generated from enum value: MODEL_PARAMETER_APPROACH_TYPE_SELF_SUPERVISED = 4;
   */
  SELF_SUPERVISED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ModelParameterApproachType)
proto3.util.setEnumType(ModelParameterApproachType, "cyclonedx.v1_6.ModelParameterApproachType", [
  { no: 0, name: "MODEL_PARAMETER_APPROACH_TYPE_SUPERVISED" },
  { no: 1, name: "MODEL_PARAMETER_APPROACH_TYPE_UNSUPERVISED" },
  { no: 2, name: "MODEL_PARAMETER_APPROACH_TYPE_REINFORCED_LEARNING" },
  { no: 3, name: "MODEL_PARAMETER_APPROACH_TYPE_SEMI_SUPERVISED" },
  { no: 4, name: "MODEL_PARAMETER_APPROACH_TYPE_SELF_SUPERVISED" },
]);

/**
 * @generated from enum cyclonedx.v1_6.ComponentDataType
 */
export enum ComponentDataType {
  /**
   * Any type of code, code snippet, or data-as-code
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error, it shall be fixed with v2.0 of this very schema
   *
   * @generated from enum value: COMPONENT_DATA_TYPE_SOURCE_CODE = 0;
   */
  SOURCE_CODE = 0,

  /**
   * Parameters or settings that may be used by other components.
   *
   * @generated from enum value: COMPONENT_DATA_TYPE_CONFIGURATION = 1;
   */
  CONFIGURATION = 1,

  /**
   * A collection of data.
   *
   * @generated from enum value: COMPONENT_DATA_TYPE_DATASET = 2;
   */
  DATASET = 2,

  /**
   * Data that can be used to create new instances of what the definition defines.
   *
   * @generated from enum value: COMPONENT_DATA_TYPE_DEFINITION = 3;
   */
  DEFINITION = 3,

  /**
   * Any other type of data that does not fit into existing definitions.
   *
   * @generated from enum value: COMPONENT_DATA_TYPE_OTHER = 4;
   */
  OTHER = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ComponentDataType)
proto3.util.setEnumType(ComponentDataType, "cyclonedx.v1_6.ComponentDataType", [
  { no: 0, name: "COMPONENT_DATA_TYPE_SOURCE_CODE" },
  { no: 1, name: "COMPONENT_DATA_TYPE_CONFIGURATION" },
  { no: 2, name: "COMPONENT_DATA_TYPE_DATASET" },
  { no: 3, name: "COMPONENT_DATA_TYPE_DEFINITION" },
  { no: 4, name: "COMPONENT_DATA_TYPE_OTHER" },
]);

/**
 * @generated from enum cyclonedx.v1_6.TaskType
 */
export enum TaskType {
  /**
   * A task that copies software or data used to accomplish other tasks in the workflow.
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
   *
   * @generated from enum value: TASK_TYPE_COPY = 0;
   */
  COPY = 0,

  /**
   * A task that clones a software repository into the workflow in order to retrieve its source code or data for use in a build step.
   *
   * @generated from enum value: TASK_TYPE_CLONE = 1;
   */
  CLONE = 1,

  /**
   * A task that checks source code for programmatic and stylistic errors.
   *
   * @generated from enum value: TASK_TYPE_LINT = 2;
   */
  LINT = 2,

  /**
   * A task that performs a scan against source code, or built or deployed components and services. Scans are typically run to gather or test for security vulnerabilities or policy compliance.
   *
   * @generated from enum value: TASK_TYPE_SCAN = 3;
   */
  SCAN = 3,

  /**
   * A task that merges changes or fixes into source code prior to a build step in the workflow.
   *
   * @generated from enum value: TASK_TYPE_MERGE = 4;
   */
  MERGE = 4,

  /**
   * A task that builds the source code, dependencies and/or data into an artifact that can be deployed to and executed on target systems.
   *
   * @generated from enum value: TASK_TYPE_BUILD = 5;
   */
  BUILD = 5,

  /**
   * A task that verifies the functionality of a component or service.
   *
   * @generated from enum value: TASK_TYPE_TEST = 6;
   */
  TEST = 6,

  /**
   * A task that delivers a built artifact to one or more target repositories or storage systems.
   *
   * @generated from enum value: TASK_TYPE_DELIVER = 7;
   */
  DELIVER = 7,

  /**
   * A task that deploys a built artifact for execution on one or more target systems.
   *
   * @generated from enum value: TASK_TYPE_DEPLOY = 8;
   */
  DEPLOY = 8,

  /**
   * A task that releases a built, versioned artifact to a target repository or distribution system.
   *
   * @generated from enum value: TASK_TYPE_RELEASE = 9;
   */
  RELEASE = 9,

  /**
   * A task that cleans unnecessary tools, build artifacts and/or data from workflow storage.
   *
   * @generated from enum value: TASK_TYPE_CLEAN = 10;
   */
  CLEAN = 10,

  /**
   * A workflow task that does not match current task type definitions.
   *
   * @generated from enum value: TASK_TYPE_OTHER = 11;
   */
  OTHER = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskType)
proto3.util.setEnumType(TaskType, "cyclonedx.v1_6.TaskType", [
  { no: 0, name: "TASK_TYPE_COPY" },
  { no: 1, name: "TASK_TYPE_CLONE" },
  { no: 2, name: "TASK_TYPE_LINT" },
  { no: 3, name: "TASK_TYPE_SCAN" },
  { no: 4, name: "TASK_TYPE_MERGE" },
  { no: 5, name: "TASK_TYPE_BUILD" },
  { no: 6, name: "TASK_TYPE_TEST" },
  { no: 7, name: "TASK_TYPE_DELIVER" },
  { no: 8, name: "TASK_TYPE_DEPLOY" },
  { no: 9, name: "TASK_TYPE_RELEASE" },
  { no: 10, name: "TASK_TYPE_CLEAN" },
  { no: 11, name: "TASK_TYPE_OTHER" },
]);

/**
 * Specifies attributes of the text
 *
 * @generated from message cyclonedx.v1_6.AttachedText
 */
export class AttachedText extends Message<AttachedText> {
  /**
   * Specifies the content type of the text. Defaults to 'text/plain' if not specified.
   *
   * @generated from field: optional string content_type = 1;
   */
  contentType?: string;

  /**
   * Specifies the optional encoding the text is represented in
   *
   * @generated from field: optional string encoding = 2;
   */
  encoding?: string;

  /**
   * SimpleContent value of element. Proactive controls such as input validation and sanitization should be employed to prevent misuse of attachment text.
   *
   * @generated from field: string value = 3;
   */
  value = "";

  constructor(data?: PartialMessage<AttachedText>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.AttachedText";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "encoding", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttachedText {
    return new AttachedText().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttachedText {
    return new AttachedText().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttachedText {
    return new AttachedText().fromJsonString(jsonString, options);
  }

  static equals(a: AttachedText | PlainMessage<AttachedText> | undefined, b: AttachedText | PlainMessage<AttachedText> | undefined): boolean {
    return proto3.util.equals(AttachedText, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Bom
 */
export class Bom extends Message<Bom> {
  /**
   * The version of the CycloneDX specification a BOM is written to (starting at version 1.3)
   *
   * @generated from field: string spec_version = 1;
   */
  specVersion = "";

  /**
   * The version allows component publishers/authors to make changes to existing BOMs to update various aspects of the document such as description or licenses. When a system is presented with multiple BOMs for the same component, the system should use the most recent version of the BOM. The default version is '1' and should be incremented for each version of the BOM that is published. Each version of a component should have a unique BOM and if no changes are made to the BOMs, then each BOM will have a version of '1'.
   *
   * @generated from field: optional int32 version = 2;
   */
  version?: number;

  /**
   * Every BOM generated should have a unique serial number, even if the contents of the BOM being generated have not changed over time. The process or tool responsible for creating the BOM should create random UUID's for every BOM generated.
   *
   * @generated from field: optional string serial_number = 3;
   */
  serialNumber?: string;

  /**
   * Provides additional information about a BOM.
   *
   * @generated from field: optional cyclonedx.v1_6.Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * Provides the ability to document a list of components.
   *
   * @generated from field: repeated cyclonedx.v1_6.Component components = 5;
   */
  components: Component[] = [];

  /**
   * Provides the ability to document a list of external services.
   *
   * @generated from field: repeated cyclonedx.v1_6.Service services = 6;
   */
  services: Service[] = [];

  /**
   * Provides the ability to document external references related to the BOM or to the project the BOM describes.
   *
   * @generated from field: repeated cyclonedx.v1_6.ExternalReference external_references = 7;
   */
  externalReferences: ExternalReference[] = [];

  /**
   * Provides the ability to document dependency relationships.
   *
   * @generated from field: repeated cyclonedx.v1_6.Dependency dependencies = 8;
   */
  dependencies: Dependency[] = [];

  /**
   * Compositions describe constituent parts (including components, services, and dependency relationships) and their completeness. The completeness of vulnerabilities expressed in a BOM may also be described.
   *
   * @generated from field: repeated cyclonedx.v1_6.Composition compositions = 9;
   */
  compositions: Composition[] = [];

  /**
   * Vulnerabilities identified in components or services.
   *
   * @generated from field: repeated cyclonedx.v1_6.Vulnerability vulnerabilities = 10;
   */
  vulnerabilities: Vulnerability[] = [];

  /**
   * Comments made by people, organizations, or tools about any object with a bom-ref, such as components, services, vulnerabilities, or the BOM itself. Unlike inventory information, annotations may contain opinion or commentary from various stakeholders.
   *
   * @generated from field: repeated cyclonedx.v1_6.Annotation annotations = 11;
   */
  annotations: Annotation[] = [];

  /**
   * Specifies optional, custom, properties
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 12;
   */
  properties: Property[] = [];

  /**
   * Describes how a component or service was manufactured or deployed. This is achieved through the use of formulas, workflows, tasks, and steps, which declare the precise steps to reproduce along with the observed formulas describing the steps which transpired in the manufacturing process.
   *
   * @generated from field: repeated cyclonedx.v1_6.Formula formulation = 13;
   */
  formulation: Formula[] = [];

  /**
   * The list of declarations which describe the conformance to standards. Each declaration may include attestations, claims, and evidence.
   *
   * @generated from field: repeated cyclonedx.v1_6.Declarations declarations = 14;
   */
  declarations: Declarations[] = [];

  /**
   * A collection of reusable objects that are defined and may be used elsewhere in the BOM.
   *
   * @generated from field: repeated cyclonedx.v1_6.Definition definitions = 15;
   */
  definitions: Definition[] = [];

  constructor(data?: PartialMessage<Bom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Bom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "serial_number", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "metadata", kind: "message", T: Metadata, opt: true },
    { no: 5, name: "components", kind: "message", T: Component, repeated: true },
    { no: 6, name: "services", kind: "message", T: Service, repeated: true },
    { no: 7, name: "external_references", kind: "message", T: ExternalReference, repeated: true },
    { no: 8, name: "dependencies", kind: "message", T: Dependency, repeated: true },
    { no: 9, name: "compositions", kind: "message", T: Composition, repeated: true },
    { no: 10, name: "vulnerabilities", kind: "message", T: Vulnerability, repeated: true },
    { no: 11, name: "annotations", kind: "message", T: Annotation, repeated: true },
    { no: 12, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 13, name: "formulation", kind: "message", T: Formula, repeated: true },
    { no: 14, name: "declarations", kind: "message", T: Declarations, repeated: true },
    { no: 15, name: "definitions", kind: "message", T: Definition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bom {
    return new Bom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bom {
    return new Bom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bom {
    return new Bom().fromJsonString(jsonString, options);
  }

  static equals(a: Bom | PlainMessage<Bom> | undefined, b: Bom | PlainMessage<Bom> | undefined): boolean {
    return proto3.util.equals(Bom, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Commit
 */
export class Commit extends Message<Commit> {
  /**
   * A unique identifier of the commit. This may be version control specific. For example, Subversion uses revision numbers whereas git uses commit hashes.
   *
   * @generated from field: optional string uid = 1;
   */
  uid?: string;

  /**
   * The URL to the commit. This URL will typically point to a commit in a version control system.
   *
   * @generated from field: optional string url = 2;
   */
  url?: string;

  /**
   * The author who created the changes in the commit
   *
   * @generated from field: optional cyclonedx.v1_6.IdentifiableAction author = 3;
   */
  author?: IdentifiableAction;

  /**
   * The person who committed or pushed the commit
   *
   * @generated from field: optional cyclonedx.v1_6.IdentifiableAction committer = 4;
   */
  committer?: IdentifiableAction;

  /**
   * The text description of the contents of the commit
   *
   * @generated from field: optional string message = 5;
   */
  message?: string;

  constructor(data?: PartialMessage<Commit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Commit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "author", kind: "message", T: IdentifiableAction, opt: true },
    { no: 4, name: "committer", kind: "message", T: IdentifiableAction, opt: true },
    { no: 5, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Commit {
    return new Commit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Commit {
    return new Commit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Commit {
    return new Commit().fromJsonString(jsonString, options);
  }

  static equals(a: Commit | PlainMessage<Commit> | undefined, b: Commit | PlainMessage<Commit> | undefined): boolean {
    return proto3.util.equals(Commit, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Component
 */
export class Component extends Message<Component> {
  /**
   * Specifies the type of component. For software components, classify as an application if no more specific appropriate classification is available or cannot be determined for the component.
   *
   * @generated from field: cyclonedx.v1_6.Classification type = 1;
   */
  type = Classification.NULL;

  /**
   * The optional mime-type of the component. When used on file components, the mime-type can provide additional context about the kind of file being represented, such as an image, font, or executable. Some library or framework components may also have an associated mime-type.
   *
   * @generated from field: optional string mime_type = 2;
   */
  mimeType?: string;

  /**
   * An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 3;
   */
  bomRef?: string;

  /**
   * The organization that supplied the component. The supplier may often be the manufacturer but may also be a distributor or repackager.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntity supplier = 4;
   */
  supplier?: OrganizationalEntity;

  /**
   * DEPRECATED - DO NOT USE - This will be removed in a future version - Use `.authors` or `.manufacturer` instead. The person(s) or organization(s) that authored the component
   *
   * @generated from field: optional string author = 5 [deprecated = true];
   * @deprecated
   */
  author?: string;

  /**
   * The person(s) or organization(s) that published the component
   *
   * @generated from field: optional string publisher = 6;
   */
  publisher?: string;

  /**
   * The grouping name or identifier. This will often be a shortened, single name of the company or project that produced the component or the source package or domain name. Whitespace and special characters should be avoided. Examples include: apache, org.apache.commons, and apache.org.
   *
   * @generated from field: optional string group = 7;
   */
  group?: string;

  /**
   * The name of the component. This will often be a shortened, single name of the component. Examples: commons-lang3 and jquery
   *
   * @generated from field: string name = 8;
   */
  name = "";

  /**
   * The component version. The version should ideally comply with semantic versioning but is not enforced. Version was made optional in v1.4 of the spec. For backward compatibility, it is RECOMMENDED to use an empty string to represent components without version information.
   *
   * @generated from field: string version = 9;
   */
  version = "";

  /**
   * Specifies a description for the component
   *
   * @generated from field: optional string description = 10;
   */
  description?: string;

  /**
   * Specifies the scope of the component. If a scope is not specified, SCOPE_REQUIRED scope should be assumed by the consumer of the BOM
   *
   * @generated from field: optional cyclonedx.v1_6.Scope scope = 11;
   */
  scope?: Scope;

  /**
   * @generated from field: repeated cyclonedx.v1_6.Hash hashes = 12;
   */
  hashes: Hash[] = [];

  /**
   * @generated from field: repeated cyclonedx.v1_6.LicenseChoice licenses = 13;
   */
  licenses: LicenseChoice[] = [];

  /**
   * An optional copyright notice informing users of the underlying claims to copyright ownership in a published work.
   *
   * @generated from field: optional string copyright = 14;
   */
  copyright?: string;

  /**
   * DEPRECATED - DO NOT USE. This will be removed in a future version. Specifies a well-formed CPE name. See https://nvd.nist.gov/products/cpe
   *
   * @generated from field: optional string cpe = 15;
   */
  cpe?: string;

  /**
   * Specifies the package-url (PURL). The purl, if specified, must be valid and conform to the specification defined at: https://github.com/package-url/purl-spec
   *
   * @generated from field: optional string purl = 16;
   */
  purl?: string;

  /**
   * Specifies metadata and content for ISO-IEC 19770-2 Software Identification (SWID) Tags.
   *
   * @generated from field: optional cyclonedx.v1_6.Swid swid = 17;
   */
  swid?: Swid;

  /**
   * DEPRECATED - DO NOT USE. This will be removed in a future version. Use the pedigree element instead to supply information on exactly how the component was modified. A boolean value indicating is the component has been modified from the original. A value of true indicates the component is a derivative of the original. A value of false indicates the component has not been modified from the original.
   *
   * @generated from field: optional bool modified = 18;
   */
  modified?: boolean;

  /**
   * Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc.
   *
   * @generated from field: optional cyclonedx.v1_6.Pedigree pedigree = 19;
   */
  pedigree?: Pedigree;

  /**
   * Provides the ability to document external references related to the component or to the project the component describes.
   *
   * @generated from field: repeated cyclonedx.v1_6.ExternalReference external_references = 20;
   */
  externalReferences: ExternalReference[] = [];

  /**
   * Specifies optional sub-components. This is not a dependency tree. It provides a way to specify a hierarchical representation of component assemblies, similar to system -> subsystem -> parts assembly in physical supply chains.
   *
   * @generated from field: repeated cyclonedx.v1_6.Component components = 21;
   */
  components: Component[] = [];

  /**
   * Specifies optional, custom, properties
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 22;
   */
  properties: Property[] = [];

  /**
   * Specifies optional license and copyright evidence
   *
   * @generated from field: optional cyclonedx.v1_6.Evidence evidence = 23;
   */
  evidence?: Evidence;

  /**
   * Specifies optional release notes.
   *
   * @generated from field: optional cyclonedx.v1_6.ReleaseNotes releaseNotes = 24;
   */
  releaseNotes?: ReleaseNotes;

  /**
   * A model card describes the intended uses of a machine learning model, potential limitations, biases, ethical considerations, training parameters, datasets used to train the model, performance metrics, and other relevant data useful for ML transparency.
   *
   * @generated from field: optional cyclonedx.v1_6.ModelCard modelCard = 25;
   */
  modelCard?: ModelCard;

  /**
   * This object SHOULD be specified for any component of type `data` and MUST NOT be specified for other component types.
   *
   * @generated from field: optional cyclonedx.v1_6.ComponentData data = 26;
   */
  data?: ComponentData;

  /**
   * Cryptographic assets have properties that uniquely define them and that make them actionable for further reasoning. As an example, it makes a difference if one knows the algorithm family (e.g. AES) or the specific variant or instantiation (e.g. AES-128-GCM). This is because the security level and the algorithm primitive (authenticated encryption) is only defined by the definition of the algorithm variant. The presence of a weak cryptographic algorithm like SHA1 vs. HMAC-SHA1 also makes a difference.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties cryptoProperties = 27;
   */
  cryptoProperties?: CryptoProperties;

  /**
   * The organization that created the component. Manufacturer is common in components created through automated processes. Components created through manual means may have `.authors` instead.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntity manufacturer = 28;
   */
  manufacturer?: OrganizationalEntity;

  /**
   * The person(s) who created the component. Authors are common in components created through manual processes. Components created through automated means may have `.manufacturer` instead.
   *
   * @generated from field: repeated cyclonedx.v1_6.OrganizationalContact authors = 29;
   */
  authors: OrganizationalContact[] = [];

  /**
   * Textual strings that aid in discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes. Examples include "json-parser", "object-persistence", "text-to-image", "translation", and "object-detection".
   *
   * @generated from field: repeated string tags = 30;
   */
  tags: string[] = [];

  /**
   * Specifies the OmniBOR Artifact ID. The OmniBOR, if specified, MUST be valid and conform to the specification defined at: https://www.iana.org/assignments/uri-schemes/prov/gitoid
   *
   * @generated from field: repeated string omniborId = 31;
   */
  omniborId: string[] = [];

  /**
   * Specifies the Software Heritage persistent identifier (SWHID). The SWHID, if specified, MUST be valid and conform to the specification defined at: https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html
   *
   * @generated from field: repeated string swhid = 32;
   */
  swhid: string[] = [];

  constructor(data?: PartialMessage<Component>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Component";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(Classification) },
    { no: 2, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "supplier", kind: "message", T: OrganizationalEntity, opt: true },
    { no: 5, name: "author", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "publisher", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "group", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "scope", kind: "enum", T: proto3.getEnumType(Scope), opt: true },
    { no: 12, name: "hashes", kind: "message", T: Hash, repeated: true },
    { no: 13, name: "licenses", kind: "message", T: LicenseChoice, repeated: true },
    { no: 14, name: "copyright", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 15, name: "cpe", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 16, name: "purl", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 17, name: "swid", kind: "message", T: Swid, opt: true },
    { no: 18, name: "modified", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 19, name: "pedigree", kind: "message", T: Pedigree, opt: true },
    { no: 20, name: "external_references", kind: "message", T: ExternalReference, repeated: true },
    { no: 21, name: "components", kind: "message", T: Component, repeated: true },
    { no: 22, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 23, name: "evidence", kind: "message", T: Evidence, opt: true },
    { no: 24, name: "releaseNotes", kind: "message", T: ReleaseNotes, opt: true },
    { no: 25, name: "modelCard", kind: "message", T: ModelCard, opt: true },
    { no: 26, name: "data", kind: "message", T: ComponentData, opt: true },
    { no: 27, name: "cryptoProperties", kind: "message", T: CryptoProperties, opt: true },
    { no: 28, name: "manufacturer", kind: "message", T: OrganizationalEntity, opt: true },
    { no: 29, name: "authors", kind: "message", T: OrganizationalContact, repeated: true },
    { no: 30, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 31, name: "omniborId", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 32, name: "swhid", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Component {
    return new Component().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Component {
    return new Component().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Component {
    return new Component().fromJsonString(jsonString, options);
  }

  static equals(a: Component | PlainMessage<Component> | undefined, b: Component | PlainMessage<Component> | undefined): boolean {
    return proto3.util.equals(Component, a, b);
  }
}

/**
 * Specifies the data flow.
 *
 * @generated from message cyclonedx.v1_6.DataFlow
 */
export class DataFlow extends Message<DataFlow> {
  /**
   * Specifies the flow direction of the data.
   *
   * @generated from field: cyclonedx.v1_6.DataFlowDirection flow = 1;
   */
  flow = DataFlowDirection.DATA_FLOW_NULL;

  /**
   * Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed.
   *
   * @generated from field: string value = 2;
   */
  value = "";

  /**
   * Name for the defined data
   *
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * Short description of the data content and usage
   *
   * @generated from field: optional string description = 4;
   */
  description?: string;

  /**
   * The URI, URL, or BOM-Link of the components or services the data came in from
   *
   * @generated from field: repeated string source = 5;
   */
  source: string[] = [];

  /**
   * The URI, URL, or BOM-Link of the components or services the data is sent to
   *
   * @generated from field: repeated string destination = 6;
   */
  destination: string[] = [];

  /**
   * Data Governance
   *
   * @generated from field: optional cyclonedx.v1_6.DataGovernance governance = 7;
   */
  governance?: DataGovernance;

  constructor(data?: PartialMessage<DataFlow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.DataFlow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "flow", kind: "enum", T: proto3.getEnumType(DataFlowDirection) },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "destination", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "governance", kind: "message", T: DataGovernance, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataFlow {
    return new DataFlow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataFlow {
    return new DataFlow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataFlow {
    return new DataFlow().fromJsonString(jsonString, options);
  }

  static equals(a: DataFlow | PlainMessage<DataFlow> | undefined, b: DataFlow | PlainMessage<DataFlow> | undefined): boolean {
    return proto3.util.equals(DataFlow, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Dependency
 */
export class Dependency extends Message<Dependency> {
  /**
   * References a component or service by its bom-ref attribute
   *
   * @generated from field: string ref = 1;
   */
  ref = "";

  /**
   * The bom-ref identifiers of the components or services that are dependencies of this dependency object.
   *
   * @generated from field: repeated cyclonedx.v1_6.Dependency dependencies = 2;
   */
  dependencies: Dependency[] = [];

  /**
   * The bom-ref identifiers of the components or services that define a given specification or standard, which are provided or implemented by this dependency object.
   *
   * @generated from field: repeated string provides = 3;
   */
  provides: string[] = [];

  constructor(data?: PartialMessage<Dependency>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Dependency";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dependencies", kind: "message", T: Dependency, repeated: true },
    { no: 3, name: "provides", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Dependency {
    return new Dependency().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Dependency {
    return new Dependency().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Dependency {
    return new Dependency().fromJsonString(jsonString, options);
  }

  static equals(a: Dependency | PlainMessage<Dependency> | undefined, b: Dependency | PlainMessage<Dependency> | undefined): boolean {
    return proto3.util.equals(Dependency, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Diff
 */
export class Diff extends Message<Diff> {
  /**
   * Specifies the optional text of the diff
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText text = 1;
   */
  text?: AttachedText;

  /**
   * Specifies the URL to the diff
   *
   * @generated from field: optional string url = 2;
   */
  url?: string;

  constructor(data?: PartialMessage<Diff>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Diff";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "message", T: AttachedText, opt: true },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Diff {
    return new Diff().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Diff {
    return new Diff().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Diff {
    return new Diff().fromJsonString(jsonString, options);
  }

  static equals(a: Diff | PlainMessage<Diff> | undefined, b: Diff | PlainMessage<Diff> | undefined): boolean {
    return proto3.util.equals(Diff, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ExternalReference
 */
export class ExternalReference extends Message<ExternalReference> {
  /**
   * Specifies the type of external reference. There are built-in types to describe common references. If a type does not exist for the reference being referred to, use the "other" type.
   *
   * @generated from field: cyclonedx.v1_6.ExternalReferenceType type = 1;
   */
  type = ExternalReferenceType.OTHER;

  /**
   * The URL to the external reference
   *
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * An optional comment describing the external reference
   *
   * @generated from field: optional string comment = 3;
   */
  comment?: string;

  /**
   * Optional integrity hashes for the external resource content
   *
   * @generated from field: repeated cyclonedx.v1_6.Hash hashes = 4;
   */
  hashes: Hash[] = [];

  constructor(data?: PartialMessage<ExternalReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ExternalReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(ExternalReferenceType) },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "hashes", kind: "message", T: Hash, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExternalReference {
    return new ExternalReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExternalReference {
    return new ExternalReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExternalReference {
    return new ExternalReference().fromJsonString(jsonString, options);
  }

  static equals(a: ExternalReference | PlainMessage<ExternalReference> | undefined, b: ExternalReference | PlainMessage<ExternalReference> | undefined): boolean {
    return proto3.util.equals(ExternalReference, a, b);
  }
}

/**
 * Specifies the file hash of the component
 *
 * @generated from message cyclonedx.v1_6.Hash
 */
export class Hash extends Message<Hash> {
  /**
   * Specifies the algorithm used to create the hash
   *
   * @generated from field: cyclonedx.v1_6.HashAlg alg = 1;
   */
  alg = HashAlg.NULL;

  /**
   * SimpleContent value of element
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<Hash>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Hash";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alg", kind: "enum", T: proto3.getEnumType(HashAlg) },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Hash {
    return new Hash().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Hash {
    return new Hash().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Hash {
    return new Hash().fromJsonString(jsonString, options);
  }

  static equals(a: Hash | PlainMessage<Hash> | undefined, b: Hash | PlainMessage<Hash> | undefined): boolean {
    return proto3.util.equals(Hash, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.IdentifiableAction
 */
export class IdentifiableAction extends Message<IdentifiableAction> {
  /**
   * The timestamp in which the action occurred
   *
   * @generated from field: optional google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The name of the individual who performed the action
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * The email address of the individual who performed the action
   *
   * @generated from field: optional string email = 3;
   */
  email?: string;

  constructor(data?: PartialMessage<IdentifiableAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.IdentifiableAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "email", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifiableAction {
    return new IdentifiableAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifiableAction {
    return new IdentifiableAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifiableAction {
    return new IdentifiableAction().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifiableAction | PlainMessage<IdentifiableAction> | undefined, b: IdentifiableAction | PlainMessage<IdentifiableAction> | undefined): boolean {
    return proto3.util.equals(IdentifiableAction, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Issue
 */
export class Issue extends Message<Issue> {
  /**
   * Specifies the type of issue
   *
   * @generated from field: cyclonedx.v1_6.IssueClassification type = 1;
   */
  type = IssueClassification.NULL;

  /**
   * The identifier of the issue assigned by the source of the issue
   *
   * @generated from field: optional string id = 2;
   */
  id?: string;

  /**
   * The name of the issue
   *
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * A description of the issue
   *
   * @generated from field: optional string description = 4;
   */
  description?: string;

  /**
   * @generated from field: optional cyclonedx.v1_6.Source source = 5;
   */
  source?: Source;

  /**
   * @generated from field: repeated string references = 6;
   */
  references: string[] = [];

  constructor(data?: PartialMessage<Issue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Issue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(IssueClassification) },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "source", kind: "message", T: Source, opt: true },
    { no: 6, name: "references", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Issue {
    return new Issue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Issue {
    return new Issue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Issue {
    return new Issue().fromJsonString(jsonString, options);
  }

  static equals(a: Issue | PlainMessage<Issue> | undefined, b: Issue | PlainMessage<Issue> | undefined): boolean {
    return proto3.util.equals(Issue, a, b);
  }
}

/**
 * The source of the issue where it is documented.
 *
 * @generated from message cyclonedx.v1_6.Source
 */
export class Source extends Message<Source> {
  /**
   * The name of the source. For example, "National Vulnerability Database", "NVD", and "Apache"
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * The url of the issue documentation as provided by the source
   *
   * @generated from field: optional string url = 2;
   */
  url?: string;

  constructor(data?: PartialMessage<Source>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Source";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source {
    return new Source().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJsonString(jsonString, options);
  }

  static equals(a: Source | PlainMessage<Source> | undefined, b: Source | PlainMessage<Source> | undefined): boolean {
    return proto3.util.equals(Source, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.LicenseChoice
 */
export class LicenseChoice extends Message<LicenseChoice> {
  /**
   * @generated from oneof cyclonedx.v1_6.LicenseChoice.choice
   */
  choice: {
    /**
     * @generated from field: cyclonedx.v1_6.License license = 1;
     */
    value: License;
    case: "license";
  } | {
    /**
     * A valid SPDX license expression. Refer to https://spdx.org/specifications for syntax requirements
     *
     * @generated from field: string expression = 2;
     */
    value: string;
    case: "expression";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * This field must only be used when "expression" is chosen as the License object has its own acknowledgement.
   *
   * @generated from field: optional cyclonedx.v1_6.LicenseAcknowledgementEnumeration acknowledgement = 3;
   */
  acknowledgement?: LicenseAcknowledgementEnumeration;

  constructor(data?: PartialMessage<LicenseChoice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.LicenseChoice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "license", kind: "message", T: License, oneof: "choice" },
    { no: 2, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "choice" },
    { no: 3, name: "acknowledgement", kind: "enum", T: proto3.getEnumType(LicenseAcknowledgementEnumeration), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LicenseChoice {
    return new LicenseChoice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LicenseChoice {
    return new LicenseChoice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LicenseChoice {
    return new LicenseChoice().fromJsonString(jsonString, options);
  }

  static equals(a: LicenseChoice | PlainMessage<LicenseChoice> | undefined, b: LicenseChoice | PlainMessage<LicenseChoice> | undefined): boolean {
    return proto3.util.equals(LicenseChoice, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.License
 */
export class License extends Message<License> {
  /**
   * @generated from oneof cyclonedx.v1_6.License.license
   */
  license: {
    /**
     * A valid SPDX license ID
     *
     * @generated from field: string id = 1;
     */
    value: string;
    case: "id";
  } | {
    /**
     * If SPDX does not define the license used, this field may be used to provide the license name
     *
     * @generated from field: string name = 2;
     */
    value: string;
    case: "name";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Specifies the optional full text of the attachment
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText text = 3;
   */
  text?: AttachedText;

  /**
   * The URL to the attachment file. If the attachment is a license or BOM, an externalReference should also be specified for completeness.
   *
   * @generated from field: optional string url = 4;
   */
  url?: string;

  /**
   * An optional identifier which can be used to reference the license elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 5;
   */
  bomRef?: string;

  /**
   * Licensing details describing the licensor/licensee, license type, renewal and expiration dates, and other important metadata
   *
   * @generated from field: optional cyclonedx.v1_6.Licensing licensing = 6;
   */
  licensing?: Licensing;

  /**
   * Specifies optional, custom, properties
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 7;
   */
  properties: Property[] = [];

  /**
   * Declared licenses and concluded licenses represent two different stages in the licensing process within software development. Declared licenses refer to the initial intention of the software authors regarding the licensing terms under which their code is released. On the other hand, concluded licenses are the result of a comprehensive analysis of the project's codebase to identify and confirm the actual licenses of the components used, which may differ from the initially declared licenses. While declared licenses provide an upfront indication of the licensing intentions, concluded licenses offer a more thorough understanding of the actual licensing within a project, facilitating proper compliance and risk management. Observed licenses are defined in `@.evidence.licenses`. Observed licenses form the evidence necessary to substantiate a concluded license.
   *
   * @generated from field: optional cyclonedx.v1_6.LicenseAcknowledgementEnumeration acknowledgement = 8;
   */
  acknowledgement?: LicenseAcknowledgementEnumeration;

  constructor(data?: PartialMessage<License>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.License";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "license" },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "license" },
    { no: 3, name: "text", kind: "message", T: AttachedText, opt: true },
    { no: 4, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "licensing", kind: "message", T: Licensing, opt: true },
    { no: 7, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 8, name: "acknowledgement", kind: "enum", T: proto3.getEnumType(LicenseAcknowledgementEnumeration), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License {
    return new License().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License {
    return new License().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License {
    return new License().fromJsonString(jsonString, options);
  }

  static equals(a: License | PlainMessage<License> | undefined, b: License | PlainMessage<License> | undefined): boolean {
    return proto3.util.equals(License, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Licensing
 */
export class Licensing extends Message<Licensing> {
  /**
   * License identifiers that may be used to manage licenses and their lifecycle
   *
   * @generated from field: repeated string altIds = 1;
   */
  altIds: string[] = [];

  /**
   * The individual or organization that grants a license to another individual or organization
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntityOrContact licensor = 2;
   */
  licensor?: OrganizationalEntityOrContact;

  /**
   * The individual or organization for which a license was granted to
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntityOrContact licensee = 3;
   */
  licensee?: OrganizationalEntityOrContact;

  /**
   * The individual or organization that purchased the license
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntityOrContact purchaser = 4;
   */
  purchaser?: OrganizationalEntityOrContact;

  /**
   * The purchase order identifier the purchaser sent to a supplier or vendor to authorize a purchase
   *
   * @generated from field: optional string purchaseOrder = 5;
   */
  purchaseOrder?: string;

  /**
   * The type of license(s) that was granted to the licensee
   *
   * @generated from field: repeated cyclonedx.v1_6.LicensingTypeEnum licenseTypes = 6;
   */
  licenseTypes: LicensingTypeEnum[] = [];

  /**
   * The timestamp indicating when the license was last renewed. For new purchases, this is often the purchase or acquisition date. For non-perpetual licenses or subscriptions, this is the timestamp of when the license was last renewed.
   *
   * @generated from field: optional google.protobuf.Timestamp lastRenewal = 7;
   */
  lastRenewal?: Timestamp;

  /**
   * The timestamp indicating when the current license expires (if applicable).
   *
   * @generated from field: optional google.protobuf.Timestamp expiration = 8;
   */
  expiration?: Timestamp;

  constructor(data?: PartialMessage<Licensing>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Licensing";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "altIds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "licensor", kind: "message", T: OrganizationalEntityOrContact, opt: true },
    { no: 3, name: "licensee", kind: "message", T: OrganizationalEntityOrContact, opt: true },
    { no: 4, name: "purchaser", kind: "message", T: OrganizationalEntityOrContact, opt: true },
    { no: 5, name: "purchaseOrder", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "licenseTypes", kind: "enum", T: proto3.getEnumType(LicensingTypeEnum), repeated: true },
    { no: 7, name: "lastRenewal", kind: "message", T: Timestamp, opt: true },
    { no: 8, name: "expiration", kind: "message", T: Timestamp, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Licensing {
    return new Licensing().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Licensing {
    return new Licensing().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Licensing {
    return new Licensing().fromJsonString(jsonString, options);
  }

  static equals(a: Licensing | PlainMessage<Licensing> | undefined, b: Licensing | PlainMessage<Licensing> | undefined): boolean {
    return proto3.util.equals(Licensing, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.OrganizationalEntityOrContact
 */
export class OrganizationalEntityOrContact extends Message<OrganizationalEntityOrContact> {
  /**
   * @generated from oneof cyclonedx.v1_6.OrganizationalEntityOrContact.choice
   */
  choice: {
    /**
     * @generated from field: cyclonedx.v1_6.OrganizationalEntity organization = 1;
     */
    value: OrganizationalEntity;
    case: "organization";
  } | {
    /**
     * @generated from field: cyclonedx.v1_6.OrganizationalContact individual = 2;
     */
    value: OrganizationalContact;
    case: "individual";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OrganizationalEntityOrContact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.OrganizationalEntityOrContact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "organization", kind: "message", T: OrganizationalEntity, oneof: "choice" },
    { no: 2, name: "individual", kind: "message", T: OrganizationalContact, oneof: "choice" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrganizationalEntityOrContact {
    return new OrganizationalEntityOrContact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrganizationalEntityOrContact {
    return new OrganizationalEntityOrContact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrganizationalEntityOrContact {
    return new OrganizationalEntityOrContact().fromJsonString(jsonString, options);
  }

  static equals(a: OrganizationalEntityOrContact | PlainMessage<OrganizationalEntityOrContact> | undefined, b: OrganizationalEntityOrContact | PlainMessage<OrganizationalEntityOrContact> | undefined): boolean {
    return proto3.util.equals(OrganizationalEntityOrContact, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * The date and time (timestamp) when the document was created.
   *
   * @generated from field: optional google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The tool(s) used in the creation of the BOM.
   *
   * @generated from field: optional cyclonedx.v1_6.Tool tools = 2;
   */
  tools?: Tool;

  /**
   * The person(s) who created the BOM. Authors are common in BOMs created through manual processes. BOMs created through automated means may have '.manufacturer' instead.
   *
   * @generated from field: repeated cyclonedx.v1_6.OrganizationalContact authors = 3;
   */
  authors: OrganizationalContact[] = [];

  /**
   * The component that the BOM describes.
   *
   * @generated from field: optional cyclonedx.v1_6.Component component = 4;
   */
  component?: Component;

  /**
   * DEPRECATED - DO NOT USE - This will be removed in a future version - Use the `.component.manufacturer` instead. The organization that manufactured the component that the BOM describes.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntity manufacture = 5 [deprecated = true];
   * @deprecated
   */
  manufacture?: OrganizationalEntity;

  /**
   * The organization that supplied the component that the BOM describes. The supplier may often be the manufacture, but may also be a distributor or repackager.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntity supplier = 6;
   */
  supplier?: OrganizationalEntity;

  /**
   * The license information for the BOM document. This may be different from the license(s) of the component(s) that the BOM describes.
   *
   * @generated from field: repeated cyclonedx.v1_6.LicenseChoice licenses = 7;
   */
  licenses: LicenseChoice[] = [];

  /**
   * Specifies optional, custom, properties
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 8;
   */
  properties: Property[] = [];

  /**
   * Lifecycles communicate the stage(s) in which data in the BOM was captured. Different types of data may be available at various phases of a lifecycle, such as the Software Development Lifecycle (SDLC), IT Asset Management (ITAM), and Software Asset Management (SAM). Thus, a BOM may include data specific to or only obtainable in a given lifecycle.
   *
   * @generated from field: repeated cyclonedx.v1_6.Lifecycles lifecycles = 9;
   */
  lifecycles: Lifecycles[] = [];

  /**
   * The organization that created the BOM. Manufacturer is common in BOMs created through automated processes. BOMs created through manual means may have '.authors' instead.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntity manufacturer = 10;
   */
  manufacturer?: OrganizationalEntity;

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp, opt: true },
    { no: 2, name: "tools", kind: "message", T: Tool, opt: true },
    { no: 3, name: "authors", kind: "message", T: OrganizationalContact, repeated: true },
    { no: 4, name: "component", kind: "message", T: Component, opt: true },
    { no: 5, name: "manufacture", kind: "message", T: OrganizationalEntity, opt: true },
    { no: 6, name: "supplier", kind: "message", T: OrganizationalEntity, opt: true },
    { no: 7, name: "licenses", kind: "message", T: LicenseChoice, repeated: true },
    { no: 8, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 9, name: "lifecycles", kind: "message", T: Lifecycles, repeated: true },
    { no: 10, name: "manufacturer", kind: "message", T: OrganizationalEntity, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Lifecycles
 */
export class Lifecycles extends Message<Lifecycles> {
  /**
   * @generated from oneof cyclonedx.v1_6.Lifecycles.choice
   */
  choice: {
    /**
     * A pre-defined phase in the product lifecycle.
     *
     * @generated from field: cyclonedx.v1_6.LifecyclePhase phase = 1;
     */
    value: LifecyclePhase;
    case: "phase";
  } | {
    /**
     * The name of the lifecycle phase
     *
     * @generated from field: string name = 2;
     */
    value: string;
    case: "name";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The description of the lifecycle phase
   *
   * @generated from field: optional string description = 3;
   */
  description?: string;

  constructor(data?: PartialMessage<Lifecycles>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Lifecycles";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phase", kind: "enum", T: proto3.getEnumType(LifecyclePhase), oneof: "choice" },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "choice" },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Lifecycles {
    return new Lifecycles().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Lifecycles {
    return new Lifecycles().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Lifecycles {
    return new Lifecycles().fromJsonString(jsonString, options);
  }

  static equals(a: Lifecycles | PlainMessage<Lifecycles> | undefined, b: Lifecycles | PlainMessage<Lifecycles> | undefined): boolean {
    return proto3.util.equals(Lifecycles, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.OrganizationalContact
 */
export class OrganizationalContact extends Message<OrganizationalContact> {
  /**
   * The name of the contact
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * The email address of the contact.
   *
   * @generated from field: optional string email = 2;
   */
  email?: string;

  /**
   * The phone number of the contact.
   *
   * @generated from field: optional string phone = 3;
   */
  phone?: string;

  /**
   * An optional identifier which can be used to reference the object elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 4;
   */
  bomRef?: string;

  constructor(data?: PartialMessage<OrganizationalContact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.OrganizationalContact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "email", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "phone", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrganizationalContact {
    return new OrganizationalContact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrganizationalContact {
    return new OrganizationalContact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrganizationalContact {
    return new OrganizationalContact().fromJsonString(jsonString, options);
  }

  static equals(a: OrganizationalContact | PlainMessage<OrganizationalContact> | undefined, b: OrganizationalContact | PlainMessage<OrganizationalContact> | undefined): boolean {
    return proto3.util.equals(OrganizationalContact, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.OrganizationalEntity
 */
export class OrganizationalEntity extends Message<OrganizationalEntity> {
  /**
   * The name of the organization
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * The URL of the organization. Multiple URLs are allowed.
   *
   * @generated from field: repeated string url = 2;
   */
  url: string[] = [];

  /**
   * A contact person at the organization. Multiple contacts are allowed.
   *
   * @generated from field: repeated cyclonedx.v1_6.OrganizationalContact contact = 3;
   */
  contact: OrganizationalContact[] = [];

  /**
   * An optional identifier which can be used to reference the object elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 4;
   */
  bomRef?: string;

  /**
   * The physical address (location) of the organization
   *
   * @generated from field: optional cyclonedx.v1_6.PostalAddressType address = 5;
   */
  address?: PostalAddressType;

  constructor(data?: PartialMessage<OrganizationalEntity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.OrganizationalEntity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "contact", kind: "message", T: OrganizationalContact, repeated: true },
    { no: 4, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "address", kind: "message", T: PostalAddressType, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrganizationalEntity {
    return new OrganizationalEntity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrganizationalEntity {
    return new OrganizationalEntity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrganizationalEntity {
    return new OrganizationalEntity().fromJsonString(jsonString, options);
  }

  static equals(a: OrganizationalEntity | PlainMessage<OrganizationalEntity> | undefined, b: OrganizationalEntity | PlainMessage<OrganizationalEntity> | undefined): boolean {
    return proto3.util.equals(OrganizationalEntity, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Patch
 */
export class Patch extends Message<Patch> {
  /**
   * Specifies the purpose for the patch, including the resolution of defects, security issues, or new behavior or functionality
   *
   * @generated from field: cyclonedx.v1_6.PatchClassification type = 1;
   */
  type = PatchClassification.NULL;

  /**
   * The patch file (or diff) that show changes. Refer to https://en.wikipedia.org/wiki/Diff
   *
   * @generated from field: optional cyclonedx.v1_6.Diff diff = 2;
   */
  diff?: Diff;

  /**
   * @generated from field: repeated cyclonedx.v1_6.Issue resolves = 3;
   */
  resolves: Issue[] = [];

  constructor(data?: PartialMessage<Patch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Patch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(PatchClassification) },
    { no: 2, name: "diff", kind: "message", T: Diff, opt: true },
    { no: 3, name: "resolves", kind: "message", T: Issue, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Patch {
    return new Patch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Patch {
    return new Patch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Patch {
    return new Patch().fromJsonString(jsonString, options);
  }

  static equals(a: Patch | PlainMessage<Patch> | undefined, b: Patch | PlainMessage<Patch> | undefined): boolean {
    return proto3.util.equals(Patch, a, b);
  }
}

/**
 * Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc. Pedigree supports viewing this complex chain from the beginning, the end, or anywhere in the middle. It also provides a way to document variants where the exact relation may not be known.
 *
 * @generated from message cyclonedx.v1_6.Pedigree
 */
export class Pedigree extends Message<Pedigree> {
  /**
   * Describes zero or more components in which a component is derived from. This is commonly used to describe forks from existing projects where the forked version contains an ancestor node containing the original component it was forked from. For example, Component A is the original component. Component B is the component being used and documented in the BOM. However, Component B contains a pedigree node with a single ancestor documenting Component A - the original component from which Component B is derived from.
   *
   * @generated from field: repeated cyclonedx.v1_6.Component ancestors = 1;
   */
  ancestors: Component[] = [];

  /**
   * Descendants are the exact opposite of ancestors. This provides a way to document all forks (and their forks) of an original or root component.
   *
   * @generated from field: repeated cyclonedx.v1_6.Component descendants = 2;
   */
  descendants: Component[] = [];

  /**
   * Variants describe relations where the relationship between the components is not known. For example, if Component A contains nearly identical code to Component B. They are both related, but it is unclear if one is derived from the other or if they share a common ancestor.
   *
   * @generated from field: repeated cyclonedx.v1_6.Component variants = 3;
   */
  variants: Component[] = [];

  /**
   * A list of zero or more commits which provide a trail describing how the component deviates from an ancestor, descendant, or variant.
   *
   * @generated from field: repeated cyclonedx.v1_6.Commit commits = 4;
   */
  commits: Commit[] = [];

  /**
   * A list of zero or more patches describing how the component deviates from an ancestor, descendant, or variant. Patches may be complementary to commits or may be used in place of commits.
   *
   * @generated from field: repeated cyclonedx.v1_6.Patch patches = 5;
   */
  patches: Patch[] = [];

  /**
   * Notes, observations, and other non-structured commentary describing the component's pedigree.
   *
   * @generated from field: optional string notes = 6;
   */
  notes?: string;

  constructor(data?: PartialMessage<Pedigree>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Pedigree";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ancestors", kind: "message", T: Component, repeated: true },
    { no: 2, name: "descendants", kind: "message", T: Component, repeated: true },
    { no: 3, name: "variants", kind: "message", T: Component, repeated: true },
    { no: 4, name: "commits", kind: "message", T: Commit, repeated: true },
    { no: 5, name: "patches", kind: "message", T: Patch, repeated: true },
    { no: 6, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pedigree {
    return new Pedigree().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pedigree {
    return new Pedigree().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pedigree {
    return new Pedigree().fromJsonString(jsonString, options);
  }

  static equals(a: Pedigree | PlainMessage<Pedigree> | undefined, b: Pedigree | PlainMessage<Pedigree> | undefined): boolean {
    return proto3.util.equals(Pedigree, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Service
 */
export class Service extends Message<Service> {
  /**
   * An optional identifier which can be used to reference the service elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The organization that provides the service.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntity provider = 2;
   */
  provider?: OrganizationalEntity;

  /**
   * The grouping name, namespace, or identifier. This will often be a shortened, single name of the company or project that produced the service or domain name. Whitespace and special characters should be avoided.
   *
   * @generated from field: optional string group = 3;
   */
  group?: string;

  /**
   * The name of the service. This will often be a shortened, single name of the service.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * The service version.
   *
   * @generated from field: optional string version = 5;
   */
  version?: string;

  /**
   * Specifies a description for the service.
   *
   * @generated from field: optional string description = 6;
   */
  description?: string;

  /**
   * @generated from field: repeated string endpoints = 7;
   */
  endpoints: string[] = [];

  /**
   * A boolean value indicating if the service requires authentication. A value of true indicates the service requires authentication prior to use. A value of false indicates the service does not require authentication.
   *
   * @generated from field: optional bool authenticated = 8;
   */
  authenticated?: boolean;

  /**
   * A boolean value indicating if the use of the service crosses a trust zone or boundary. A value of true indicates that by using the service, a trust boundary is crossed. A value of false indicates that by using the service, a trust boundary is not crossed.
   *
   * @generated from field: optional bool x_trust_boundary = 9;
   */
  xTrustBoundary?: boolean;

  /**
   * @generated from field: repeated cyclonedx.v1_6.DataFlow data = 10;
   */
  data: DataFlow[] = [];

  /**
   * @generated from field: repeated cyclonedx.v1_6.LicenseChoice licenses = 11;
   */
  licenses: LicenseChoice[] = [];

  /**
   * Provides the ability to document external references related to the service.
   *
   * @generated from field: repeated cyclonedx.v1_6.ExternalReference external_references = 12;
   */
  externalReferences: ExternalReference[] = [];

  /**
   * Specifies optional sub-service. This is not a dependency tree. It provides a way to specify a hierarchical representation of service assemblies, similar to system -> subsystem -> parts assembly in physical supply chains.
   *
   * @generated from field: repeated cyclonedx.v1_6.Service services = 13;
   */
  services: Service[] = [];

  /**
   * Specifies optional, custom, properties
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 14;
   */
  properties: Property[] = [];

  /**
   * Specifies optional release notes.
   *
   * @generated from field: optional cyclonedx.v1_6.ReleaseNotes releaseNotes = 15;
   */
  releaseNotes?: ReleaseNotes;

  /**
   * The name of the trust zone the service resides in.
   *
   * @generated from field: optional string trustZone = 16;
   */
  trustZone?: string;

  /**
   * Textual strings that aid in the discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes. Examples include "json-parser", "object-persistence", "text-to-image", "translation", and "object-detection".
   *
   * @generated from field: repeated string tags = 17;
   */
  tags: string[] = [];

  constructor(data?: PartialMessage<Service>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Service";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "provider", kind: "message", T: OrganizationalEntity, opt: true },
    { no: 3, name: "group", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "authenticated", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 9, name: "x_trust_boundary", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 10, name: "data", kind: "message", T: DataFlow, repeated: true },
    { no: 11, name: "licenses", kind: "message", T: LicenseChoice, repeated: true },
    { no: 12, name: "external_references", kind: "message", T: ExternalReference, repeated: true },
    { no: 13, name: "services", kind: "message", T: Service, repeated: true },
    { no: 14, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 15, name: "releaseNotes", kind: "message", T: ReleaseNotes, opt: true },
    { no: 16, name: "trustZone", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 17, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Service {
    return new Service().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Service {
    return new Service().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Service {
    return new Service().fromJsonString(jsonString, options);
  }

  static equals(a: Service | PlainMessage<Service> | undefined, b: Service | PlainMessage<Service> | undefined): boolean {
    return proto3.util.equals(Service, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Swid
 */
export class Swid extends Message<Swid> {
  /**
   * Maps to the tagId of a SoftwareIdentity.
   *
   * @generated from field: string tag_id = 1;
   */
  tagId = "";

  /**
   * Maps to the name of a SoftwareIdentity.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Maps to the version of a SoftwareIdentity. Defaults to '0.0' if not specified.
   *
   * @generated from field: optional string version = 3;
   */
  version?: string;

  /**
   * Maps to the tagVersion of a SoftwareIdentity. Defaults to '0' if not specified.
   *
   * @generated from field: optional int32 tag_version = 4;
   */
  tagVersion?: number;

  /**
   * Maps to the patch of a SoftwareIdentity. Defaults to 'false' if not specified.
   *
   * @generated from field: optional bool patch = 5;
   */
  patch?: boolean;

  /**
   * Specifies the full content of the SWID tag.
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText text = 6;
   */
  text?: AttachedText;

  /**
   * The URL to the SWID file.
   *
   * @generated from field: optional string url = 7;
   */
  url?: string;

  constructor(data?: PartialMessage<Swid>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Swid";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tag_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "tag_version", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "patch", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "text", kind: "message", T: AttachedText, opt: true },
    { no: 7, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Swid {
    return new Swid().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Swid {
    return new Swid().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Swid {
    return new Swid().fromJsonString(jsonString, options);
  }

  static equals(a: Swid | PlainMessage<Swid> | undefined, b: Swid | PlainMessage<Swid> | undefined): boolean {
    return proto3.util.equals(Swid, a, b);
  }
}

/**
 * Specifies a tool (manual or automated).
 *
 * @generated from message cyclonedx.v1_6.Tool
 */
export class Tool extends Message<Tool> {
  /**
   * DEPRECATED - DO NOT USE - The vendor of the tool used to create the BOM.
   *
   * @generated from field: optional string vendor = 1 [deprecated = true];
   * @deprecated
   */
  vendor?: string;

  /**
   * DEPRECATED - DO NOT USE - The name of the tool used to create the BOM.
   *
   * @generated from field: optional string name = 2 [deprecated = true];
   * @deprecated
   */
  name?: string;

  /**
   * DEPRECATED - DO NOT USE - The version of the tool used to create the BOM.
   *
   * @generated from field: optional string version = 3 [deprecated = true];
   * @deprecated
   */
  version?: string;

  /**
   * DEPRECATED - DO NOT USE
   *
   * @generated from field: repeated cyclonedx.v1_6.Hash hashes = 4 [deprecated = true];
   * @deprecated
   */
  hashes: Hash[] = [];

  /**
   * DEPRECATED - DO NOT USE - Provides the ability to document external references related to the tool.
   *
   * @generated from field: repeated cyclonedx.v1_6.ExternalReference external_references = 5 [deprecated = true];
   * @deprecated
   */
  externalReferences: ExternalReference[] = [];

  /**
   * A list of software and hardware components used as tools
   *
   * @generated from field: repeated cyclonedx.v1_6.Component components = 6;
   */
  components: Component[] = [];

  /**
   * A list of services used as tools. This may include microservices, function-as-a-service, and other types of network or intra-process services.
   *
   * @generated from field: repeated cyclonedx.v1_6.Service services = 7;
   */
  services: Service[] = [];

  constructor(data?: PartialMessage<Tool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Tool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vendor", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "hashes", kind: "message", T: Hash, repeated: true },
    { no: 5, name: "external_references", kind: "message", T: ExternalReference, repeated: true },
    { no: 6, name: "components", kind: "message", T: Component, repeated: true },
    { no: 7, name: "services", kind: "message", T: Service, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tool {
    return new Tool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tool {
    return new Tool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tool {
    return new Tool().fromJsonString(jsonString, options);
  }

  static equals(a: Tool | PlainMessage<Tool> | undefined, b: Tool | PlainMessage<Tool> | undefined): boolean {
    return proto3.util.equals(Tool, a, b);
  }
}

/**
 * Specifies a property
 *
 * @generated from message cyclonedx.v1_6.Property
 */
export class Property extends Message<Property> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: optional string value = 2;
   */
  value?: string;

  constructor(data?: PartialMessage<Property>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Property";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Property {
    return new Property().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJsonString(jsonString, options);
  }

  static equals(a: Property | PlainMessage<Property> | undefined, b: Property | PlainMessage<Property> | undefined): boolean {
    return proto3.util.equals(Property, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Composition
 */
export class Composition extends Message<Composition> {
  /**
   * Indicates the aggregate completeness
   *
   * @generated from field: cyclonedx.v1_6.Aggregate aggregate = 1;
   */
  aggregate = Aggregate.NOT_SPECIFIED;

  /**
   * The assemblies the aggregate completeness applies to
   *
   * @generated from field: repeated string assemblies = 2;
   */
  assemblies: string[] = [];

  /**
   * The dependencies the aggregate completeness applies to
   *
   * @generated from field: repeated string dependencies = 3;
   */
  dependencies: string[] = [];

  /**
   * The bom-ref identifiers of the vulnerabilities being described.
   *
   * @generated from field: repeated string vulnerabilities = 4;
   */
  vulnerabilities: string[] = [];

  /**
   * An optional identifier which can be used to reference the composition elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
   *
   * @generated from field: optional string bom_ref = 5;
   */
  bomRef?: string;

  constructor(data?: PartialMessage<Composition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Composition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregate", kind: "enum", T: proto3.getEnumType(Aggregate) },
    { no: 2, name: "assemblies", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "dependencies", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "vulnerabilities", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Composition {
    return new Composition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Composition {
    return new Composition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Composition {
    return new Composition().fromJsonString(jsonString, options);
  }

  static equals(a: Composition | PlainMessage<Composition> | undefined, b: Composition | PlainMessage<Composition> | undefined): boolean {
    return proto3.util.equals(Composition, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.EvidenceCopyright
 */
export class EvidenceCopyright extends Message<EvidenceCopyright> {
  /**
   * Copyright text
   *
   * @generated from field: string text = 1;
   */
  text = "";

  constructor(data?: PartialMessage<EvidenceCopyright>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.EvidenceCopyright";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EvidenceCopyright {
    return new EvidenceCopyright().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EvidenceCopyright {
    return new EvidenceCopyright().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EvidenceCopyright {
    return new EvidenceCopyright().fromJsonString(jsonString, options);
  }

  static equals(a: EvidenceCopyright | PlainMessage<EvidenceCopyright> | undefined, b: EvidenceCopyright | PlainMessage<EvidenceCopyright> | undefined): boolean {
    return proto3.util.equals(EvidenceCopyright, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Evidence
 */
export class Evidence extends Message<Evidence> {
  /**
   * @generated from field: repeated cyclonedx.v1_6.LicenseChoice licenses = 1;
   */
  licenses: LicenseChoice[] = [];

  /**
   * @generated from field: repeated cyclonedx.v1_6.EvidenceCopyright copyright = 2;
   */
  copyright: EvidenceCopyright[] = [];

  /**
   * @generated from field: repeated cyclonedx.v1_6.EvidenceIdentity identity = 3;
   */
  identity: EvidenceIdentity[] = [];

  /**
   * @generated from field: repeated cyclonedx.v1_6.EvidenceOccurrences occurrences = 4;
   */
  occurrences: EvidenceOccurrences[] = [];

  /**
   * @generated from field: optional cyclonedx.v1_6.Callstack callstack = 5;
   */
  callstack?: Callstack;

  constructor(data?: PartialMessage<Evidence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Evidence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "licenses", kind: "message", T: LicenseChoice, repeated: true },
    { no: 2, name: "copyright", kind: "message", T: EvidenceCopyright, repeated: true },
    { no: 3, name: "identity", kind: "message", T: EvidenceIdentity, repeated: true },
    { no: 4, name: "occurrences", kind: "message", T: EvidenceOccurrences, repeated: true },
    { no: 5, name: "callstack", kind: "message", T: Callstack, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Evidence {
    return new Evidence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Evidence {
    return new Evidence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Evidence {
    return new Evidence().fromJsonString(jsonString, options);
  }

  static equals(a: Evidence | PlainMessage<Evidence> | undefined, b: Evidence | PlainMessage<Evidence> | undefined): boolean {
    return proto3.util.equals(Evidence, a, b);
  }
}

/**
 * Evidence of the components use through the callstack.
 *
 * @generated from message cyclonedx.v1_6.Callstack
 */
export class Callstack extends Message<Callstack> {
  /**
   * @generated from field: repeated cyclonedx.v1_6.Callstack.Frames frames = 1;
   */
  frames: Callstack_Frames[] = [];

  constructor(data?: PartialMessage<Callstack>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Callstack";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "frames", kind: "message", T: Callstack_Frames, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Callstack {
    return new Callstack().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Callstack {
    return new Callstack().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Callstack {
    return new Callstack().fromJsonString(jsonString, options);
  }

  static equals(a: Callstack | PlainMessage<Callstack> | undefined, b: Callstack | PlainMessage<Callstack> | undefined): boolean {
    return proto3.util.equals(Callstack, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Callstack.Frames
 */
export class Callstack_Frames extends Message<Callstack_Frames> {
  /**
   * A package organizes modules into namespaces, providing a unique namespace for each type it contains.
   *
   * @generated from field: optional string package = 1;
   */
  package?: string;

  /**
   * A module or class that encloses functions/methods and other code.
   *
   * @generated from field: string module = 2;
   */
  module = "";

  /**
   * A block of code designed to perform a particular task.
   *
   * @generated from field: optional string function = 3;
   */
  function?: string;

  /**
   * Optional arguments that are passed to the module or function.
   *
   * @generated from field: repeated string parameters = 4;
   */
  parameters: string[] = [];

  /**
   * The line number the code that is called resides on.
   *
   * @generated from field: optional int32 line = 5;
   */
  line?: number;

  /**
   * The column the code that is called resides.
   *
   * @generated from field: optional int32 column = 6;
   */
  column?: number;

  /**
   * The full path and filename of the module.
   *
   * @generated from field: optional string fullFilename = 7;
   */
  fullFilename?: string;

  constructor(data?: PartialMessage<Callstack_Frames>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Callstack.Frames";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "package", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "module", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "function", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "parameters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "line", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "column", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "fullFilename", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Callstack_Frames {
    return new Callstack_Frames().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Callstack_Frames {
    return new Callstack_Frames().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Callstack_Frames {
    return new Callstack_Frames().fromJsonString(jsonString, options);
  }

  static equals(a: Callstack_Frames | PlainMessage<Callstack_Frames> | undefined, b: Callstack_Frames | PlainMessage<Callstack_Frames> | undefined): boolean {
    return proto3.util.equals(Callstack_Frames, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.EvidenceIdentity
 */
export class EvidenceIdentity extends Message<EvidenceIdentity> {
  /**
   * The identity field of the component which the evidence describes.
   *
   * @generated from field: cyclonedx.v1_6.EvidenceFieldType field = 1;
   */
  field = EvidenceFieldType.EVIDENCE_FIELD_NULL;

  /**
   * The overall confidence of the evidence from 0 - 1, where 1 is 100% confidence.
   *
   * @generated from field: optional float confidence = 2;
   */
  confidence?: number;

  /**
   * The methods used to extract and/or analyze the evidence.
   *
   * @generated from field: repeated cyclonedx.v1_6.EvidenceMethods methods = 3;
   */
  methods: EvidenceMethods[] = [];

  /**
   * The object in the BOM identified by its bom-ref. This is often a component or service, but may be any object type supporting bom-refs. Tools used for analysis should already be defined in the BOM, either in the metadata/tools, components, or formulation.
   *
   * @generated from field: repeated string tools = 4;
   */
  tools: string[] = [];

  /**
   * The value of the field (cpe, purl, etc) that has been concluded based on the aggregate of all methods (if available).
   *
   * @generated from field: optional string concludedValue = 5;
   */
  concludedValue?: string;

  constructor(data?: PartialMessage<EvidenceIdentity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.EvidenceIdentity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "enum", T: proto3.getEnumType(EvidenceFieldType) },
    { no: 2, name: "confidence", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 3, name: "methods", kind: "message", T: EvidenceMethods, repeated: true },
    { no: 4, name: "tools", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "concludedValue", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EvidenceIdentity {
    return new EvidenceIdentity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EvidenceIdentity {
    return new EvidenceIdentity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EvidenceIdentity {
    return new EvidenceIdentity().fromJsonString(jsonString, options);
  }

  static equals(a: EvidenceIdentity | PlainMessage<EvidenceIdentity> | undefined, b: EvidenceIdentity | PlainMessage<EvidenceIdentity> | undefined): boolean {
    return proto3.util.equals(EvidenceIdentity, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.EvidenceMethods
 */
export class EvidenceMethods extends Message<EvidenceMethods> {
  /**
   * The technique used in this method of analysis.
   *
   * @generated from field: cyclonedx.v1_6.EvidenceTechnique technique = 1;
   */
  technique = EvidenceTechnique.SOURCE_CODE_ANALYSIS;

  /**
   * The confidence of the evidence from 0 - 1, where 1 is 100% confidence. Confidence is specific to the technique used. Each technique of analysis can have independent confidence.
   *
   * @generated from field: float confidence = 2;
   */
  confidence = 0;

  /**
   * The value or contents of the evidence.
   *
   * @generated from field: optional string value = 3;
   */
  value?: string;

  constructor(data?: PartialMessage<EvidenceMethods>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.EvidenceMethods";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "technique", kind: "enum", T: proto3.getEnumType(EvidenceTechnique) },
    { no: 2, name: "confidence", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EvidenceMethods {
    return new EvidenceMethods().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EvidenceMethods {
    return new EvidenceMethods().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EvidenceMethods {
    return new EvidenceMethods().fromJsonString(jsonString, options);
  }

  static equals(a: EvidenceMethods | PlainMessage<EvidenceMethods> | undefined, b: EvidenceMethods | PlainMessage<EvidenceMethods> | undefined): boolean {
    return proto3.util.equals(EvidenceMethods, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.EvidenceOccurrences
 */
export class EvidenceOccurrences extends Message<EvidenceOccurrences> {
  /**
   * An optional identifier which can be used to reference the occurrence elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The location or path to where the component was found.
   *
   * @generated from field: string location = 2;
   */
  location = "";

  /**
   * The line number where the component was found.
   *
   * @generated from field: optional int32 line = 3;
   */
  line?: number;

  /**
   * The offset where the component was found.
   *
   * @generated from field: optional int32 offset = 4;
   */
  offset?: number;

  /**
   * The symbol name that was found associated with the component.
   *
   * @generated from field: optional string symbol = 5;
   */
  symbol?: string;

  /**
   * Any additional context of the detected component (e.g. a code snippet).
   *
   * @generated from field: optional string additionalContext = 6;
   */
  additionalContext?: string;

  constructor(data?: PartialMessage<EvidenceOccurrences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.EvidenceOccurrences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "line", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "offset", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "additionalContext", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EvidenceOccurrences {
    return new EvidenceOccurrences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EvidenceOccurrences {
    return new EvidenceOccurrences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EvidenceOccurrences {
    return new EvidenceOccurrences().fromJsonString(jsonString, options);
  }

  static equals(a: EvidenceOccurrences | PlainMessage<EvidenceOccurrences> | undefined, b: EvidenceOccurrences | PlainMessage<EvidenceOccurrences> | undefined): boolean {
    return proto3.util.equals(EvidenceOccurrences, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Note
 */
export class Note extends Message<Note> {
  /**
   * The ISO-639 (or higher) language code and optional ISO-3166 (or higher) country code. Examples include: "en", "en-US", "fr" and "fr-CA".
   *
   * @generated from field: optional string locale = 1;
   */
  locale?: string;

  /**
   * Specifies the full content of the release note.
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText text = 2;
   */
  text?: AttachedText;

  constructor(data?: PartialMessage<Note>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Note";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locale", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "text", kind: "message", T: AttachedText, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Note {
    return new Note().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Note {
    return new Note().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Note {
    return new Note().fromJsonString(jsonString, options);
  }

  static equals(a: Note | PlainMessage<Note> | undefined, b: Note | PlainMessage<Note> | undefined): boolean {
    return proto3.util.equals(Note, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ReleaseNotes
 */
export class ReleaseNotes extends Message<ReleaseNotes> {
  /**
   * The software versioning type. It is RECOMMENDED that the release type use one of 'major', 'minor', 'patch', 'pre-release', or 'internal'. Representing all possible software release types is not practical, so standardizing on the recommended values, whenever possible, is strongly encouraged.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * The title of the release.
   *
   * @generated from field: optional string title = 2;
   */
  title?: string;

  /**
   * The URL to an image that may be prominently displayed with the release note.
   *
   * @generated from field: optional string featuredImage = 3;
   */
  featuredImage?: string;

  /**
   * The URL to an image that may be used in messaging on social media platforms.
   *
   * @generated from field: optional string socialImage = 4;
   */
  socialImage?: string;

  /**
   * A short description of the release.
   *
   * @generated from field: optional string description = 5;
   */
  description?: string;

  /**
   * The date and time (timestamp) when the release note was created.
   *
   * @generated from field: optional google.protobuf.Timestamp timestamp = 6;
   */
  timestamp?: Timestamp;

  /**
   * Optional alternate names the release may be referred to. This may include unofficial terms used by development and marketing teams (e.g. code names).
   *
   * @generated from field: repeated string aliases = 7;
   */
  aliases: string[] = [];

  /**
   * Textual strings that aid in the discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes. Examples include "json-parser", "object-persistence", "text-to-image", "translation", and "object-detection".
   *
   * @generated from field: repeated string tags = 8;
   */
  tags: string[] = [];

  /**
   * A collection of issues that have been resolved.
   *
   * @generated from field: repeated cyclonedx.v1_6.Issue resolves = 9;
   */
  resolves: Issue[] = [];

  /**
   * Zero or more release notes containing the locale and content. Multiple note messages may be specified to support release notes in a wide variety of languages.
   *
   * @generated from field: repeated cyclonedx.v1_6.Note notes = 10;
   */
  notes: Note[] = [];

  /**
   * Specifies optional, custom, properties
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 11;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<ReleaseNotes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ReleaseNotes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "featuredImage", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "socialImage", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "timestamp", kind: "message", T: Timestamp, opt: true },
    { no: 7, name: "aliases", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "resolves", kind: "message", T: Issue, repeated: true },
    { no: 10, name: "notes", kind: "message", T: Note, repeated: true },
    { no: 11, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseNotes {
    return new ReleaseNotes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseNotes {
    return new ReleaseNotes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseNotes {
    return new ReleaseNotes().fromJsonString(jsonString, options);
  }

  static equals(a: ReleaseNotes | PlainMessage<ReleaseNotes> | undefined, b: ReleaseNotes | PlainMessage<ReleaseNotes> | undefined): boolean {
    return proto3.util.equals(ReleaseNotes, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Vulnerability
 */
export class Vulnerability extends Message<Vulnerability> {
  /**
   * An optional identifier which can be used to reference the vulnerability elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The identifier that uniquely identifies the vulnerability.
   *
   * @generated from field: optional string id = 2;
   */
  id?: string;

  /**
   * The source that published the vulnerability.
   *
   * @generated from field: optional cyclonedx.v1_6.Source source = 3;
   */
  source?: Source;

  /**
   * Zero or more pointers to vulnerabilities that are the equivalent of the vulnerability specified. Oftentimes, the same vulnerability may exist in multiple sources of vulnerability intelligence but have different identifiers. References provide a way to correlate vulnerabilities across multiple sources of vulnerability intelligence.
   *
   * @generated from field: repeated cyclonedx.v1_6.VulnerabilityReference references = 4;
   */
  references: VulnerabilityReference[] = [];

  /**
   * List of vulnerability ratings
   *
   * @generated from field: repeated cyclonedx.v1_6.VulnerabilityRating ratings = 5;
   */
  ratings: VulnerabilityRating[] = [];

  /**
   * List of Common Weaknesses Enumerations (CWEs) codes that describe this vulnerability. For example, 399 (of https://cwe.mitre.org/data/definitions/399.html)
   *
   * @generated from field: repeated int32 cwes = 6;
   */
  cwes: number[] = [];

  /**
   * A description of the vulnerability as provided by the source.
   *
   * @generated from field: optional string description = 7;
   */
  description?: string;

  /**
   * If available, an in-depth description of the vulnerability as provided by the source organization. Details often include information useful in understanding the root cause.
   *
   * @generated from field: optional string detail = 8;
   */
  detail?: string;

  /**
   * Recommendations of how the vulnerability can be remediated or mitigated.
   *
   * @generated from field: optional string recommendation = 9;
   */
  recommendation?: string;

  /**
   * Published advisories of the vulnerability if provided.
   *
   * @generated from field: repeated cyclonedx.v1_6.Advisory advisories = 10;
   */
  advisories: Advisory[] = [];

  /**
   * The date and time (timestamp) when the vulnerability record was created in the vulnerability database.
   *
   * @generated from field: optional google.protobuf.Timestamp created = 11;
   */
  created?: Timestamp;

  /**
   * The date and time (timestamp) when the vulnerability record was first published.
   *
   * @generated from field: optional google.protobuf.Timestamp published = 12;
   */
  published?: Timestamp;

  /**
   * The date and time (timestamp) when the vulnerability record was last updated.
   *
   * @generated from field: optional google.protobuf.Timestamp updated = 13;
   */
  updated?: Timestamp;

  /**
   * Individuals or organizations credited with the discovery of the vulnerability.
   *
   * @generated from field: optional cyclonedx.v1_6.VulnerabilityCredits credits = 14;
   */
  credits?: VulnerabilityCredits;

  /**
   * The tool(s) used to identify, confirm, or score the vulnerability.
   *
   * @generated from field: optional cyclonedx.v1_6.Tool tools = 15;
   */
  tools?: Tool;

  /**
   * An assessment of the impact and exploitability of the vulnerability.
   *
   * @generated from field: optional cyclonedx.v1_6.VulnerabilityAnalysis analysis = 16;
   */
  analysis?: VulnerabilityAnalysis;

  /**
   * affects
   *
   * @generated from field: repeated cyclonedx.v1_6.VulnerabilityAffects affects = 17;
   */
  affects: VulnerabilityAffects[] = [];

  /**
   * Specifies optional, custom, properties
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 18;
   */
  properties: Property[] = [];

  /**
   * The date and time (timestamp) when the vulnerability record was rejected (if applicable).
   *
   * @generated from field: optional google.protobuf.Timestamp rejected = 19;
   */
  rejected?: Timestamp;

  /**
   * Evidence used to reproduce the vulnerability.
   *
   * @generated from field: optional cyclonedx.v1_6.ProofOfConcept proofOfConcept = 20;
   */
  proofOfConcept?: ProofOfConcept;

  /**
   * A bypass, usually temporary, of the vulnerability that reduces its likelihood and/or impact. Workarounds often involve changes to configuration or deployments.
   *
   * @generated from field: optional string workaround = 21;
   */
  workaround?: string;

  constructor(data?: PartialMessage<Vulnerability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Vulnerability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "source", kind: "message", T: Source, opt: true },
    { no: 4, name: "references", kind: "message", T: VulnerabilityReference, repeated: true },
    { no: 5, name: "ratings", kind: "message", T: VulnerabilityRating, repeated: true },
    { no: 6, name: "cwes", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 7, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "detail", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "recommendation", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "advisories", kind: "message", T: Advisory, repeated: true },
    { no: 11, name: "created", kind: "message", T: Timestamp, opt: true },
    { no: 12, name: "published", kind: "message", T: Timestamp, opt: true },
    { no: 13, name: "updated", kind: "message", T: Timestamp, opt: true },
    { no: 14, name: "credits", kind: "message", T: VulnerabilityCredits, opt: true },
    { no: 15, name: "tools", kind: "message", T: Tool, opt: true },
    { no: 16, name: "analysis", kind: "message", T: VulnerabilityAnalysis, opt: true },
    { no: 17, name: "affects", kind: "message", T: VulnerabilityAffects, repeated: true },
    { no: 18, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 19, name: "rejected", kind: "message", T: Timestamp, opt: true },
    { no: 20, name: "proofOfConcept", kind: "message", T: ProofOfConcept, opt: true },
    { no: 21, name: "workaround", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vulnerability {
    return new Vulnerability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vulnerability {
    return new Vulnerability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vulnerability {
    return new Vulnerability().fromJsonString(jsonString, options);
  }

  static equals(a: Vulnerability | PlainMessage<Vulnerability> | undefined, b: Vulnerability | PlainMessage<Vulnerability> | undefined): boolean {
    return proto3.util.equals(Vulnerability, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ProofOfConcept
 */
export class ProofOfConcept extends Message<ProofOfConcept> {
  /**
   * Precise steps to reproduce the vulnerability.
   *
   * @generated from field: optional string reproductionSteps = 1;
   */
  reproductionSteps?: string;

  /**
   * A description of the environment in which reproduction was possible.
   *
   * @generated from field: optional string environment = 2;
   */
  environment?: string;

  /**
   * Supporting material that helps in reproducing or understanding how reproduction is possible. This may include screenshots, payloads, and PoC exploit code.
   *
   * @generated from field: repeated cyclonedx.v1_6.AttachedText supportingMaterial = 3;
   */
  supportingMaterial: AttachedText[] = [];

  constructor(data?: PartialMessage<ProofOfConcept>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ProofOfConcept";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reproductionSteps", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "environment", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "supportingMaterial", kind: "message", T: AttachedText, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProofOfConcept {
    return new ProofOfConcept().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProofOfConcept {
    return new ProofOfConcept().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProofOfConcept {
    return new ProofOfConcept().fromJsonString(jsonString, options);
  }

  static equals(a: ProofOfConcept | PlainMessage<ProofOfConcept> | undefined, b: ProofOfConcept | PlainMessage<ProofOfConcept> | undefined): boolean {
    return proto3.util.equals(ProofOfConcept, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.VulnerabilityReference
 */
export class VulnerabilityReference extends Message<VulnerabilityReference> {
  /**
   * An identifier that uniquely identifies the vulnerability.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The source that published the vulnerability.
   *
   * @generated from field: cyclonedx.v1_6.Source source = 2;
   */
  source?: Source;

  constructor(data?: PartialMessage<VulnerabilityReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.VulnerabilityReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source", kind: "message", T: Source },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VulnerabilityReference {
    return new VulnerabilityReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VulnerabilityReference {
    return new VulnerabilityReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VulnerabilityReference {
    return new VulnerabilityReference().fromJsonString(jsonString, options);
  }

  static equals(a: VulnerabilityReference | PlainMessage<VulnerabilityReference> | undefined, b: VulnerabilityReference | PlainMessage<VulnerabilityReference> | undefined): boolean {
    return proto3.util.equals(VulnerabilityReference, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.VulnerabilityRating
 */
export class VulnerabilityRating extends Message<VulnerabilityRating> {
  /**
   * The source that calculated the severity or risk rating of the vulnerability.
   *
   * @generated from field: optional cyclonedx.v1_6.Source source = 1;
   */
  source?: Source;

  /**
   * The numerical score of the rating.
   *
   * @generated from field: optional double score = 2;
   */
  score?: number;

  /**
   * Textual representation of the severity that corresponds to the numerical score of the rating.
   *
   * @generated from field: optional cyclonedx.v1_6.Severity severity = 3;
   */
  severity?: Severity;

  /**
   * Specifies the severity or risk scoring methodology or standard used.
   *
   * @generated from field: optional cyclonedx.v1_6.ScoreMethod method = 4;
   */
  method?: ScoreMethod;

  /**
   * Textual representation of the metric values used to score the vulnerability.
   *
   * @generated from field: optional string vector = 5;
   */
  vector?: string;

  /**
   * An optional reason for rating the vulnerability as it was.
   *
   * @generated from field: optional string justification = 6;
   */
  justification?: string;

  constructor(data?: PartialMessage<VulnerabilityRating>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.VulnerabilityRating";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: Source, opt: true },
    { no: 2, name: "score", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "severity", kind: "enum", T: proto3.getEnumType(Severity), opt: true },
    { no: 4, name: "method", kind: "enum", T: proto3.getEnumType(ScoreMethod), opt: true },
    { no: 5, name: "vector", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "justification", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VulnerabilityRating {
    return new VulnerabilityRating().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VulnerabilityRating {
    return new VulnerabilityRating().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VulnerabilityRating {
    return new VulnerabilityRating().fromJsonString(jsonString, options);
  }

  static equals(a: VulnerabilityRating | PlainMessage<VulnerabilityRating> | undefined, b: VulnerabilityRating | PlainMessage<VulnerabilityRating> | undefined): boolean {
    return proto3.util.equals(VulnerabilityRating, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Advisory
 */
export class Advisory extends Message<Advisory> {
  /**
   * An optional name of the advisory.
   *
   * @generated from field: optional string title = 1;
   */
  title?: string;

  /**
   * Location where the advisory can be obtained.
   *
   * @generated from field: string url = 2;
   */
  url = "";

  constructor(data?: PartialMessage<Advisory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Advisory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Advisory {
    return new Advisory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Advisory {
    return new Advisory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Advisory {
    return new Advisory().fromJsonString(jsonString, options);
  }

  static equals(a: Advisory | PlainMessage<Advisory> | undefined, b: Advisory | PlainMessage<Advisory> | undefined): boolean {
    return proto3.util.equals(Advisory, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.VulnerabilityCredits
 */
export class VulnerabilityCredits extends Message<VulnerabilityCredits> {
  /**
   * The organizations credited with vulnerability discovery.
   *
   * @generated from field: repeated cyclonedx.v1_6.OrganizationalEntity organizations = 1;
   */
  organizations: OrganizationalEntity[] = [];

  /**
   * The individuals not associated with organizations that are credited with vulnerability discovery.
   *
   * @generated from field: repeated cyclonedx.v1_6.OrganizationalContact individuals = 2;
   */
  individuals: OrganizationalContact[] = [];

  constructor(data?: PartialMessage<VulnerabilityCredits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.VulnerabilityCredits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "organizations", kind: "message", T: OrganizationalEntity, repeated: true },
    { no: 2, name: "individuals", kind: "message", T: OrganizationalContact, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VulnerabilityCredits {
    return new VulnerabilityCredits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VulnerabilityCredits {
    return new VulnerabilityCredits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VulnerabilityCredits {
    return new VulnerabilityCredits().fromJsonString(jsonString, options);
  }

  static equals(a: VulnerabilityCredits | PlainMessage<VulnerabilityCredits> | undefined, b: VulnerabilityCredits | PlainMessage<VulnerabilityCredits> | undefined): boolean {
    return proto3.util.equals(VulnerabilityCredits, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.VulnerabilityAnalysis
 */
export class VulnerabilityAnalysis extends Message<VulnerabilityAnalysis> {
  /**
   * Declares the current state of an occurrence of a vulnerability after automated or manual analysis.
   *
   * @generated from field: optional cyclonedx.v1_6.ImpactAnalysisState state = 1;
   */
  state?: ImpactAnalysisState;

  /**
   * The rationale of why the impact analysis state was asserted.
   *
   * @generated from field: optional cyclonedx.v1_6.ImpactAnalysisJustification justification = 2;
   */
  justification?: ImpactAnalysisJustification;

  /**
   * A response to the vulnerability by the manufacturer, supplier, or project responsible for the affected component or service. More than one response is allowed. Responses are strongly encouraged for vulnerabilities where the analysis state is exploitable.
   *
   * @generated from field: repeated cyclonedx.v1_6.VulnerabilityResponse response = 3;
   */
  response: VulnerabilityResponse[] = [];

  /**
   * Detailed description of the impact, including methods used during the assessment. If a vulnerability is not exploitable, this field should include specific details on why the component or service is not impacted by this vulnerability.
   *
   * @generated from field: optional string detail = 4;
   */
  detail?: string;

  /**
   * The date and time (timestamp) when the analysis was first issued.
   *
   * @generated from field: optional google.protobuf.Timestamp firstIssued = 5;
   */
  firstIssued?: Timestamp;

  /**
   * The date and time (timestamp) when the analysis was last updated.
   *
   * @generated from field: optional google.protobuf.Timestamp lastUpdated = 6;
   */
  lastUpdated?: Timestamp;

  constructor(data?: PartialMessage<VulnerabilityAnalysis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.VulnerabilityAnalysis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(ImpactAnalysisState), opt: true },
    { no: 2, name: "justification", kind: "enum", T: proto3.getEnumType(ImpactAnalysisJustification), opt: true },
    { no: 3, name: "response", kind: "enum", T: proto3.getEnumType(VulnerabilityResponse), repeated: true },
    { no: 4, name: "detail", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "firstIssued", kind: "message", T: Timestamp, opt: true },
    { no: 6, name: "lastUpdated", kind: "message", T: Timestamp, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VulnerabilityAnalysis {
    return new VulnerabilityAnalysis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VulnerabilityAnalysis {
    return new VulnerabilityAnalysis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VulnerabilityAnalysis {
    return new VulnerabilityAnalysis().fromJsonString(jsonString, options);
  }

  static equals(a: VulnerabilityAnalysis | PlainMessage<VulnerabilityAnalysis> | undefined, b: VulnerabilityAnalysis | PlainMessage<VulnerabilityAnalysis> | undefined): boolean {
    return proto3.util.equals(VulnerabilityAnalysis, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.VulnerabilityAffects
 */
export class VulnerabilityAffects extends Message<VulnerabilityAffects> {
  /**
   * References a component or service by the objects bom-ref
   *
   * @generated from field: string ref = 1;
   */
  ref = "";

  /**
   * Zero or more individual versions or range of versions.
   *
   * @generated from field: repeated cyclonedx.v1_6.VulnerabilityAffectedVersions versions = 2;
   */
  versions: VulnerabilityAffectedVersions[] = [];

  constructor(data?: PartialMessage<VulnerabilityAffects>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.VulnerabilityAffects";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "versions", kind: "message", T: VulnerabilityAffectedVersions, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VulnerabilityAffects {
    return new VulnerabilityAffects().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VulnerabilityAffects {
    return new VulnerabilityAffects().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VulnerabilityAffects {
    return new VulnerabilityAffects().fromJsonString(jsonString, options);
  }

  static equals(a: VulnerabilityAffects | PlainMessage<VulnerabilityAffects> | undefined, b: VulnerabilityAffects | PlainMessage<VulnerabilityAffects> | undefined): boolean {
    return proto3.util.equals(VulnerabilityAffects, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.VulnerabilityAffectedVersions
 */
export class VulnerabilityAffectedVersions extends Message<VulnerabilityAffectedVersions> {
  /**
   * @generated from oneof cyclonedx.v1_6.VulnerabilityAffectedVersions.choice
   */
  choice: {
    /**
     * A single version of a component or service.
     *
     * @generated from field: string version = 1;
     */
    value: string;
    case: "version";
  } | {
    /**
     * A version range specified in Package URL Version Range syntax (vers), which is defined at https://github.com/package-url/purl-spec/VERSION-RANGE-SPEC.rst
     *
     * @generated from field: string range = 2;
     */
    value: string;
    case: "range";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The vulnerability status for the version or range of versions. Defaults to VULNERABILITY_AFFECTED_STATUS_AFFECTED if not specified.
   *
   * @generated from field: optional cyclonedx.v1_6.VulnerabilityAffectedStatus status = 3;
   */
  status?: VulnerabilityAffectedStatus;

  constructor(data?: PartialMessage<VulnerabilityAffectedVersions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.VulnerabilityAffectedVersions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "choice" },
    { no: 2, name: "range", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "choice" },
    { no: 3, name: "status", kind: "enum", T: proto3.getEnumType(VulnerabilityAffectedStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VulnerabilityAffectedVersions {
    return new VulnerabilityAffectedVersions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VulnerabilityAffectedVersions {
    return new VulnerabilityAffectedVersions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VulnerabilityAffectedVersions {
    return new VulnerabilityAffectedVersions().fromJsonString(jsonString, options);
  }

  static equals(a: VulnerabilityAffectedVersions | PlainMessage<VulnerabilityAffectedVersions> | undefined, b: VulnerabilityAffectedVersions | PlainMessage<VulnerabilityAffectedVersions> | undefined): boolean {
    return proto3.util.equals(VulnerabilityAffectedVersions, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.AnnotatorChoice
 */
export class AnnotatorChoice extends Message<AnnotatorChoice> {
  /**
   * @generated from oneof cyclonedx.v1_6.AnnotatorChoice.choice
   */
  choice: {
    /**
     * The organization that created the annotation
     *
     * @generated from field: cyclonedx.v1_6.OrganizationalEntity organization = 1;
     */
    value: OrganizationalEntity;
    case: "organization";
  } | {
    /**
     * The person that created the annotation
     *
     * @generated from field: cyclonedx.v1_6.OrganizationalContact individual = 2;
     */
    value: OrganizationalContact;
    case: "individual";
  } | {
    /**
     * The tool or component that created the annotation
     *
     * @generated from field: cyclonedx.v1_6.Component component = 3;
     */
    value: Component;
    case: "component";
  } | {
    /**
     * The service that created the annotation
     *
     * @generated from field: cyclonedx.v1_6.Service service = 4;
     */
    value: Service;
    case: "service";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AnnotatorChoice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.AnnotatorChoice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "organization", kind: "message", T: OrganizationalEntity, oneof: "choice" },
    { no: 2, name: "individual", kind: "message", T: OrganizationalContact, oneof: "choice" },
    { no: 3, name: "component", kind: "message", T: Component, oneof: "choice" },
    { no: 4, name: "service", kind: "message", T: Service, oneof: "choice" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnotatorChoice {
    return new AnnotatorChoice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnotatorChoice {
    return new AnnotatorChoice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnotatorChoice {
    return new AnnotatorChoice().fromJsonString(jsonString, options);
  }

  static equals(a: AnnotatorChoice | PlainMessage<AnnotatorChoice> | undefined, b: AnnotatorChoice | PlainMessage<AnnotatorChoice> | undefined): boolean {
    return proto3.util.equals(AnnotatorChoice, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Annotation
 */
export class Annotation extends Message<Annotation> {
  /**
   * An optional identifier which can be used to reference the annotation elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The object in the BOM identified by its bom-ref. This is often a component or service but may be any object type supporting bom-refs.
   *
   * @generated from field: repeated string subjects = 2;
   */
  subjects: string[] = [];

  /**
   * The organization, person, component, or service which created the textual content of the annotation.
   *
   * @generated from field: cyclonedx.v1_6.AnnotatorChoice annotator = 3;
   */
  annotator?: AnnotatorChoice;

  /**
   * The date and time (timestamp) when the annotation was created.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  /**
   * The textual content of the annotation.
   *
   * @generated from field: string text = 5;
   */
  text = "";

  constructor(data?: PartialMessage<Annotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Annotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "subjects", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "annotator", kind: "message", T: AnnotatorChoice },
    { no: 4, name: "timestamp", kind: "message", T: Timestamp },
    { no: 5, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Annotation {
    return new Annotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Annotation {
    return new Annotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Annotation {
    return new Annotation().fromJsonString(jsonString, options);
  }

  static equals(a: Annotation | PlainMessage<Annotation> | undefined, b: Annotation | PlainMessage<Annotation> | undefined): boolean {
    return proto3.util.equals(Annotation, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard
 */
export class ModelCard extends Message<ModelCard> {
  /**
   * An optional identifier which can be used to reference the model card elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * Hyper-parameters for construction of the model.
   *
   * @generated from field: optional cyclonedx.v1_6.ModelCard.ModelParameters modelParameters = 2;
   */
  modelParameters?: ModelCard_ModelParameters;

  /**
   * A quantitative analysis of the model
   *
   * @generated from field: optional cyclonedx.v1_6.ModelCard.QuantitativeAnalysis quantitativeAnalysis = 3;
   */
  quantitativeAnalysis?: ModelCard_QuantitativeAnalysis;

  /**
   * What considerations should be taken into account regarding the model's construction, training, and application?
   *
   * @generated from field: optional cyclonedx.v1_6.ModelCard.ModelCardConsiderations considerations = 4;
   */
  considerations?: ModelCard_ModelCardConsiderations;

  constructor(data?: PartialMessage<ModelCard>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "modelParameters", kind: "message", T: ModelCard_ModelParameters, opt: true },
    { no: 3, name: "quantitativeAnalysis", kind: "message", T: ModelCard_QuantitativeAnalysis, opt: true },
    { no: 4, name: "considerations", kind: "message", T: ModelCard_ModelCardConsiderations, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard {
    return new ModelCard().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard {
    return new ModelCard().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard {
    return new ModelCard().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard | PlainMessage<ModelCard> | undefined, b: ModelCard | PlainMessage<ModelCard> | undefined): boolean {
    return proto3.util.equals(ModelCard, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.ModelParameters
 */
export class ModelCard_ModelParameters extends Message<ModelCard_ModelParameters> {
  /**
   * The overall approach to learning used by the model for problem-solving.
   *
   * @generated from field: optional cyclonedx.v1_6.ModelCard.ModelParameters.Approach approach = 1;
   */
  approach?: ModelCard_ModelParameters_Approach;

  /**
   * Directly influences the input and/or output. Examples include classification, regression, clustering, etc.
   *
   * @generated from field: optional string task = 2;
   */
  task?: string;

  /**
   * The model architecture family such as transformer network, convolutional neural network, residual neural network, LSTM neural network, etc.
   *
   * @generated from field: optional string architectureFamily = 3;
   */
  architectureFamily?: string;

  /**
   * The specific architecture of the model, such as GPT-1, ResNet-50, YOLOv3, etc.
   *
   * @generated from field: optional string modelArchitecture = 4;
   */
  modelArchitecture?: string;

  /**
   * The datasets used to train and evaluate the model.
   *
   * @generated from field: repeated cyclonedx.v1_6.ModelCard.ModelParameters.Datasets datasets = 5;
   */
  datasets: ModelCard_ModelParameters_Datasets[] = [];

  /**
   * The input format(s) of the model
   *
   * @generated from field: repeated cyclonedx.v1_6.ModelCard.ModelParameters.MachineLearningInputOutputParameters inputs = 6;
   */
  inputs: ModelCard_ModelParameters_MachineLearningInputOutputParameters[] = [];

  /**
   * The output format(s) from the model
   *
   * @generated from field: repeated cyclonedx.v1_6.ModelCard.ModelParameters.MachineLearningInputOutputParameters outputs = 7;
   */
  outputs: ModelCard_ModelParameters_MachineLearningInputOutputParameters[] = [];

  constructor(data?: PartialMessage<ModelCard_ModelParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.ModelParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "approach", kind: "message", T: ModelCard_ModelParameters_Approach, opt: true },
    { no: 2, name: "task", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "architectureFamily", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "modelArchitecture", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "datasets", kind: "message", T: ModelCard_ModelParameters_Datasets, repeated: true },
    { no: 6, name: "inputs", kind: "message", T: ModelCard_ModelParameters_MachineLearningInputOutputParameters, repeated: true },
    { no: 7, name: "outputs", kind: "message", T: ModelCard_ModelParameters_MachineLearningInputOutputParameters, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_ModelParameters {
    return new ModelCard_ModelParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_ModelParameters {
    return new ModelCard_ModelParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_ModelParameters {
    return new ModelCard_ModelParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_ModelParameters | PlainMessage<ModelCard_ModelParameters> | undefined, b: ModelCard_ModelParameters | PlainMessage<ModelCard_ModelParameters> | undefined): boolean {
    return proto3.util.equals(ModelCard_ModelParameters, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.ModelParameters.Approach
 */
export class ModelCard_ModelParameters_Approach extends Message<ModelCard_ModelParameters_Approach> {
  /**
   * @generated from field: optional cyclonedx.v1_6.ModelParameterApproachType type = 1;
   */
  type?: ModelParameterApproachType;

  constructor(data?: PartialMessage<ModelCard_ModelParameters_Approach>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.ModelParameters.Approach";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(ModelParameterApproachType), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_ModelParameters_Approach {
    return new ModelCard_ModelParameters_Approach().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_ModelParameters_Approach {
    return new ModelCard_ModelParameters_Approach().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_ModelParameters_Approach {
    return new ModelCard_ModelParameters_Approach().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_ModelParameters_Approach | PlainMessage<ModelCard_ModelParameters_Approach> | undefined, b: ModelCard_ModelParameters_Approach | PlainMessage<ModelCard_ModelParameters_Approach> | undefined): boolean {
    return proto3.util.equals(ModelCard_ModelParameters_Approach, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.ModelParameters.Datasets
 */
export class ModelCard_ModelParameters_Datasets extends Message<ModelCard_ModelParameters_Datasets> {
  /**
   * @generated from oneof cyclonedx.v1_6.ModelCard.ModelParameters.Datasets.choice
   */
  choice: {
    /**
     * @generated from field: cyclonedx.v1_6.ComponentData dataset = 1;
     */
    value: ComponentData;
    case: "dataset";
  } | {
    /**
     * References a data component by the components bom-ref attribute
     *
     * @generated from field: string ref = 2;
     */
    value: string;
    case: "ref";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ModelCard_ModelParameters_Datasets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.ModelParameters.Datasets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dataset", kind: "message", T: ComponentData, oneof: "choice" },
    { no: 2, name: "ref", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "choice" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_ModelParameters_Datasets {
    return new ModelCard_ModelParameters_Datasets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_ModelParameters_Datasets {
    return new ModelCard_ModelParameters_Datasets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_ModelParameters_Datasets {
    return new ModelCard_ModelParameters_Datasets().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_ModelParameters_Datasets | PlainMessage<ModelCard_ModelParameters_Datasets> | undefined, b: ModelCard_ModelParameters_Datasets | PlainMessage<ModelCard_ModelParameters_Datasets> | undefined): boolean {
    return proto3.util.equals(ModelCard_ModelParameters_Datasets, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.ModelParameters.MachineLearningInputOutputParameters
 */
export class ModelCard_ModelParameters_MachineLearningInputOutputParameters extends Message<ModelCard_ModelParameters_MachineLearningInputOutputParameters> {
  /**
   * The data format for input/output to the model. Example formats include string, image, time-series
   *
   * @generated from field: optional string format = 1;
   */
  format?: string;

  constructor(data?: PartialMessage<ModelCard_ModelParameters_MachineLearningInputOutputParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.ModelParameters.MachineLearningInputOutputParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "format", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_ModelParameters_MachineLearningInputOutputParameters {
    return new ModelCard_ModelParameters_MachineLearningInputOutputParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_ModelParameters_MachineLearningInputOutputParameters {
    return new ModelCard_ModelParameters_MachineLearningInputOutputParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_ModelParameters_MachineLearningInputOutputParameters {
    return new ModelCard_ModelParameters_MachineLearningInputOutputParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_ModelParameters_MachineLearningInputOutputParameters | PlainMessage<ModelCard_ModelParameters_MachineLearningInputOutputParameters> | undefined, b: ModelCard_ModelParameters_MachineLearningInputOutputParameters | PlainMessage<ModelCard_ModelParameters_MachineLearningInputOutputParameters> | undefined): boolean {
    return proto3.util.equals(ModelCard_ModelParameters_MachineLearningInputOutputParameters, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.QuantitativeAnalysis
 */
export class ModelCard_QuantitativeAnalysis extends Message<ModelCard_QuantitativeAnalysis> {
  /**
   * The model performance metrics being reported. Examples may include accuracy, F1 score, precision, top-3 error rates, MSC, etc.
   *
   * @generated from field: repeated cyclonedx.v1_6.ModelCard.QuantitativeAnalysis.PerformanceMetrics performanceMetrics = 1;
   */
  performanceMetrics: ModelCard_QuantitativeAnalysis_PerformanceMetrics[] = [];

  /**
   * @generated from field: optional cyclonedx.v1_6.GraphicsCollection graphics = 2;
   */
  graphics?: GraphicsCollection;

  constructor(data?: PartialMessage<ModelCard_QuantitativeAnalysis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.QuantitativeAnalysis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "performanceMetrics", kind: "message", T: ModelCard_QuantitativeAnalysis_PerformanceMetrics, repeated: true },
    { no: 2, name: "graphics", kind: "message", T: GraphicsCollection, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_QuantitativeAnalysis {
    return new ModelCard_QuantitativeAnalysis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_QuantitativeAnalysis {
    return new ModelCard_QuantitativeAnalysis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_QuantitativeAnalysis {
    return new ModelCard_QuantitativeAnalysis().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_QuantitativeAnalysis | PlainMessage<ModelCard_QuantitativeAnalysis> | undefined, b: ModelCard_QuantitativeAnalysis | PlainMessage<ModelCard_QuantitativeAnalysis> | undefined): boolean {
    return proto3.util.equals(ModelCard_QuantitativeAnalysis, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.QuantitativeAnalysis.PerformanceMetrics
 */
export class ModelCard_QuantitativeAnalysis_PerformanceMetrics extends Message<ModelCard_QuantitativeAnalysis_PerformanceMetrics> {
  /**
   * The type of performance metric.
   *
   * @generated from field: optional string type = 1;
   */
  type?: string;

  /**
   * The value of the performance metric.
   *
   * @generated from field: optional string value = 2;
   */
  value?: string;

  /**
   * The name of the slice this metric was computed on. By default, assume this metric is not sliced.
   *
   * @generated from field: optional string slice = 3;
   */
  slice?: string;

  /**
   * The confidence interval of the metric.
   *
   * @generated from field: optional cyclonedx.v1_6.ModelCard.QuantitativeAnalysis.PerformanceMetrics.ConfidenceInterval confidenceInterval = 4;
   */
  confidenceInterval?: ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval;

  constructor(data?: PartialMessage<ModelCard_QuantitativeAnalysis_PerformanceMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.QuantitativeAnalysis.PerformanceMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "slice", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "confidenceInterval", kind: "message", T: ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_QuantitativeAnalysis_PerformanceMetrics {
    return new ModelCard_QuantitativeAnalysis_PerformanceMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_QuantitativeAnalysis_PerformanceMetrics {
    return new ModelCard_QuantitativeAnalysis_PerformanceMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_QuantitativeAnalysis_PerformanceMetrics {
    return new ModelCard_QuantitativeAnalysis_PerformanceMetrics().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_QuantitativeAnalysis_PerformanceMetrics | PlainMessage<ModelCard_QuantitativeAnalysis_PerformanceMetrics> | undefined, b: ModelCard_QuantitativeAnalysis_PerformanceMetrics | PlainMessage<ModelCard_QuantitativeAnalysis_PerformanceMetrics> | undefined): boolean {
    return proto3.util.equals(ModelCard_QuantitativeAnalysis_PerformanceMetrics, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.QuantitativeAnalysis.PerformanceMetrics.ConfidenceInterval
 */
export class ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval extends Message<ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval> {
  /**
   * The lower bound of the confidence interval.
   *
   * @generated from field: optional string lowerBound = 1;
   */
  lowerBound?: string;

  /**
   * The upper bound of the confidence interval.
   *
   * @generated from field: optional string upperBound = 2;
   */
  upperBound?: string;

  constructor(data?: PartialMessage<ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.QuantitativeAnalysis.PerformanceMetrics.ConfidenceInterval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lowerBound", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "upperBound", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval {
    return new ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval {
    return new ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval {
    return new ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval | PlainMessage<ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval> | undefined, b: ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval | PlainMessage<ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval> | undefined): boolean {
    return proto3.util.equals(ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.ModelCardConsiderations
 */
export class ModelCard_ModelCardConsiderations extends Message<ModelCard_ModelCardConsiderations> {
  /**
   * Who are the intended users of the model?
   *
   * @generated from field: repeated string users = 1;
   */
  users: string[] = [];

  /**
   * What are the intended use cases of the model?
   *
   * @generated from field: repeated string useCases = 2;
   */
  useCases: string[] = [];

  /**
   * What are the known technical limitations of the model? E.g. What kind(s) of data should the model be expected not to perform well on? What are the factors that might degrade model performance?
   *
   * @generated from field: repeated string technicalLimitations = 3;
   */
  technicalLimitations: string[] = [];

  /**
   * What are the known tradeoffs in accuracy/performance of the model?
   *
   * @generated from field: repeated string performanceTradeoffs = 4;
   */
  performanceTradeoffs: string[] = [];

  /**
   * What are the ethical risks involved in the application of this model?
   *
   * @generated from field: repeated cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EthicalConsiderations ethicalConsiderations = 5;
   */
  ethicalConsiderations: ModelCard_ModelCardConsiderations_EthicalConsiderations[] = [];

  /**
   * How does the model affect groups at risk of being systematically disadvantaged? What are the harms and benefits to the various affected groups?
   *
   * @generated from field: repeated cyclonedx.v1_6.ModelCard.ModelCardConsiderations.FairnessAssessments fairnessAssessments = 6;
   */
  fairnessAssessments: ModelCard_ModelCardConsiderations_FairnessAssessments[] = [];

  /**
   * What are the various environmental impacts the corresponding machine learning model has exhibited across its lifecycle?
   *
   * @generated from field: optional cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EnvironmentalConsiderations environmentalConsiderations = 7;
   */
  environmentalConsiderations?: ModelCard_ModelCardConsiderations_EnvironmentalConsiderations;

  constructor(data?: PartialMessage<ModelCard_ModelCardConsiderations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.ModelCardConsiderations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "users", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "useCases", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "technicalLimitations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "performanceTradeoffs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "ethicalConsiderations", kind: "message", T: ModelCard_ModelCardConsiderations_EthicalConsiderations, repeated: true },
    { no: 6, name: "fairnessAssessments", kind: "message", T: ModelCard_ModelCardConsiderations_FairnessAssessments, repeated: true },
    { no: 7, name: "environmentalConsiderations", kind: "message", T: ModelCard_ModelCardConsiderations_EnvironmentalConsiderations, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_ModelCardConsiderations {
    return new ModelCard_ModelCardConsiderations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations {
    return new ModelCard_ModelCardConsiderations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations {
    return new ModelCard_ModelCardConsiderations().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_ModelCardConsiderations | PlainMessage<ModelCard_ModelCardConsiderations> | undefined, b: ModelCard_ModelCardConsiderations | PlainMessage<ModelCard_ModelCardConsiderations> | undefined): boolean {
    return proto3.util.equals(ModelCard_ModelCardConsiderations, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EthicalConsiderations
 */
export class ModelCard_ModelCardConsiderations_EthicalConsiderations extends Message<ModelCard_ModelCardConsiderations_EthicalConsiderations> {
  /**
   * The name of the risk.
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * Strategy used to address this risk.
   *
   * @generated from field: optional string mitigationStrategy = 2;
   */
  mitigationStrategy?: string;

  constructor(data?: PartialMessage<ModelCard_ModelCardConsiderations_EthicalConsiderations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EthicalConsiderations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "mitigationStrategy", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_ModelCardConsiderations_EthicalConsiderations {
    return new ModelCard_ModelCardConsiderations_EthicalConsiderations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations_EthicalConsiderations {
    return new ModelCard_ModelCardConsiderations_EthicalConsiderations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations_EthicalConsiderations {
    return new ModelCard_ModelCardConsiderations_EthicalConsiderations().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_ModelCardConsiderations_EthicalConsiderations | PlainMessage<ModelCard_ModelCardConsiderations_EthicalConsiderations> | undefined, b: ModelCard_ModelCardConsiderations_EthicalConsiderations | PlainMessage<ModelCard_ModelCardConsiderations_EthicalConsiderations> | undefined): boolean {
    return proto3.util.equals(ModelCard_ModelCardConsiderations_EthicalConsiderations, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.ModelCardConsiderations.FairnessAssessments
 */
export class ModelCard_ModelCardConsiderations_FairnessAssessments extends Message<ModelCard_ModelCardConsiderations_FairnessAssessments> {
  /**
   * The groups or individuals at risk of being systematically disadvantaged by the model.
   *
   * @generated from field: optional string groupAtRisk = 1;
   */
  groupAtRisk?: string;

  /**
   * Expected benefits to the identified groups.
   *
   * @generated from field: optional string benefits = 2;
   */
  benefits?: string;

  /**
   * Expected harms to the identified groups.
   *
   * @generated from field: optional string harms = 3;
   */
  harms?: string;

  /**
   * With respect to the benefits and harms outlined, please describe any mitigation strategy implemented.
   *
   * @generated from field: optional string mitigationStrategy = 4;
   */
  mitigationStrategy?: string;

  constructor(data?: PartialMessage<ModelCard_ModelCardConsiderations_FairnessAssessments>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.ModelCardConsiderations.FairnessAssessments";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groupAtRisk", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "benefits", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "harms", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "mitigationStrategy", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_ModelCardConsiderations_FairnessAssessments {
    return new ModelCard_ModelCardConsiderations_FairnessAssessments().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations_FairnessAssessments {
    return new ModelCard_ModelCardConsiderations_FairnessAssessments().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations_FairnessAssessments {
    return new ModelCard_ModelCardConsiderations_FairnessAssessments().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_ModelCardConsiderations_FairnessAssessments | PlainMessage<ModelCard_ModelCardConsiderations_FairnessAssessments> | undefined, b: ModelCard_ModelCardConsiderations_FairnessAssessments | PlainMessage<ModelCard_ModelCardConsiderations_FairnessAssessments> | undefined): boolean {
    return proto3.util.equals(ModelCard_ModelCardConsiderations_FairnessAssessments, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EnvironmentalConsiderations
 */
export class ModelCard_ModelCardConsiderations_EnvironmentalConsiderations extends Message<ModelCard_ModelCardConsiderations_EnvironmentalConsiderations> {
  /**
   * Describes energy consumption information incurred for one or more component lifecycle activities.
   *
   * @generated from field: repeated cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EnergyConsumption energyConsumptions = 1;
   */
  energyConsumptions: ModelCard_ModelCardConsiderations_EnergyConsumption[] = [];

  /**
   * Specifies optional, custom properties for environment considerations
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 2;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<ModelCard_ModelCardConsiderations_EnvironmentalConsiderations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EnvironmentalConsiderations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "energyConsumptions", kind: "message", T: ModelCard_ModelCardConsiderations_EnergyConsumption, repeated: true },
    { no: 2, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_ModelCardConsiderations_EnvironmentalConsiderations {
    return new ModelCard_ModelCardConsiderations_EnvironmentalConsiderations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations_EnvironmentalConsiderations {
    return new ModelCard_ModelCardConsiderations_EnvironmentalConsiderations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations_EnvironmentalConsiderations {
    return new ModelCard_ModelCardConsiderations_EnvironmentalConsiderations().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_ModelCardConsiderations_EnvironmentalConsiderations | PlainMessage<ModelCard_ModelCardConsiderations_EnvironmentalConsiderations> | undefined, b: ModelCard_ModelCardConsiderations_EnvironmentalConsiderations | PlainMessage<ModelCard_ModelCardConsiderations_EnvironmentalConsiderations> | undefined): boolean {
    return proto3.util.equals(ModelCard_ModelCardConsiderations_EnvironmentalConsiderations, a, b);
  }
}

/**
 * Describes energy consumption information incurred for the specified lifecycle activity.
 *
 * @generated from message cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EnergyConsumption
 */
export class ModelCard_ModelCardConsiderations_EnergyConsumption extends Message<ModelCard_ModelCardConsiderations_EnergyConsumption> {
  /**
   * The type of activity that is part of a machine learning model development or operational lifecycle.
   *
   * @generated from field: cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EnergyConsumption.ActivityType activity = 1;
   */
  activity = ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.UNSPECIFIED;

  /**
   * The providers of the energy consumed by the associated model development lifecycle activity.
   *
   * @generated from field: repeated cyclonedx.v1_6.EnergyProviderType energyProviders = 2;
   */
  energyProviders: EnergyProviderType[] = [];

  /**
   * The total energy cost associated with the model lifecycle activity.
   *
   * @generated from field: cyclonedx.v1_6.EnergyMeasureType activityEnergyCost = 3;
   */
  activityEnergyCost?: EnergyMeasureType;

  /**
   * The CO2 cost or debit equivalent to the total energy cost.
   *
   * @generated from field: optional cyclonedx.v1_6.CO2MeasureType co2CostEquivalent = 4;
   */
  co2CostEquivalent?: CO2MeasureType;

  /**
   * The CO2 offset or credit for the CO2 equivalent cost.
   *
   * @generated from field: optional cyclonedx.v1_6.CO2MeasureType co2CostOffset = 5;
   */
  co2CostOffset?: CO2MeasureType;

  /**
   * Specifies optional, custom properties for environment considerations
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 6;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<ModelCard_ModelCardConsiderations_EnergyConsumption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EnergyConsumption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "activity", kind: "enum", T: proto3.getEnumType(ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType) },
    { no: 2, name: "energyProviders", kind: "message", T: EnergyProviderType, repeated: true },
    { no: 3, name: "activityEnergyCost", kind: "message", T: EnergyMeasureType },
    { no: 4, name: "co2CostEquivalent", kind: "message", T: CO2MeasureType, opt: true },
    { no: 5, name: "co2CostOffset", kind: "message", T: CO2MeasureType, opt: true },
    { no: 6, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelCard_ModelCardConsiderations_EnergyConsumption {
    return new ModelCard_ModelCardConsiderations_EnergyConsumption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations_EnergyConsumption {
    return new ModelCard_ModelCardConsiderations_EnergyConsumption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelCard_ModelCardConsiderations_EnergyConsumption {
    return new ModelCard_ModelCardConsiderations_EnergyConsumption().fromJsonString(jsonString, options);
  }

  static equals(a: ModelCard_ModelCardConsiderations_EnergyConsumption | PlainMessage<ModelCard_ModelCardConsiderations_EnergyConsumption> | undefined, b: ModelCard_ModelCardConsiderations_EnergyConsumption | PlainMessage<ModelCard_ModelCardConsiderations_EnergyConsumption> | undefined): boolean {
    return proto3.util.equals(ModelCard_ModelCardConsiderations_EnergyConsumption, a, b);
  }
}

/**
 * An activity that is part of a machine learning model development or operational lifecycle.
 *
 * @generated from enum cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EnergyConsumption.ActivityType
 */
export enum ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType {
  /**
   * @generated from enum value: ACTIVITY_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * a lifecycle activity type whose description does not match currently defined values (the default type).
   *
   * @generated from enum value: ACTIVITY_TYPE_OTHER = 1;
   */
  OTHER = 1,

  /**
   * model design including problem framing, goal definition and algorithm selection.
   *
   * @generated from enum value: ACTIVITY_TYPE_DESIGN = 2;
   */
  DESIGN = 2,

  /**
   * model data acquisition including search, selection and transfer.
   *
   * @generated from enum value: ACTIVITY_TYPE_DATA_COLLECTION = 3;
   */
  DATA_COLLECTION = 3,

  /**
   * model data preparation including data cleaning, labeling and conversion.
   *
   * @generated from enum value: ACTIVITY_TYPE_DATA_PREPARATION = 4;
   */
  DATA_PREPARATION = 4,

  /**
   * model building, training and generalized tuning.
   *
   * @generated from enum value: ACTIVITY_TYPE_TRAINING = 5;
   */
  TRAINING = 5,

  /**
   * refining a trained model to produce desired outputs for a given problem space.
   *
   * @generated from enum value: ACTIVITY_TYPE_FINE_TUNING = 6;
   */
  FINE_TUNING = 6,

  /**
   * model validation including model output evaluation and testing.
   *
   * @generated from enum value: ACTIVITY_TYPE_VALIDATION = 7;
   */
  VALIDATION = 7,

  /**
   * explicit model deployment to a target hosting infrastructure.
   *
   * @generated from enum value: ACTIVITY_TYPE_DEPLOYMENT = 8;
   */
  DEPLOYMENT = 8,

  /**
   * generating an output response from a hosted model from a set of inputs.
   *
   * @generated from enum value: ACTIVITY_TYPE_INFERENCE = 9;
   */
  INFERENCE = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType)
proto3.util.setEnumType(ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType, "cyclonedx.v1_6.ModelCard.ModelCardConsiderations.EnergyConsumption.ActivityType", [
  { no: 0, name: "ACTIVITY_TYPE_UNSPECIFIED" },
  { no: 1, name: "ACTIVITY_TYPE_OTHER" },
  { no: 2, name: "ACTIVITY_TYPE_DESIGN" },
  { no: 3, name: "ACTIVITY_TYPE_DATA_COLLECTION" },
  { no: 4, name: "ACTIVITY_TYPE_DATA_PREPARATION" },
  { no: 5, name: "ACTIVITY_TYPE_TRAINING" },
  { no: 6, name: "ACTIVITY_TYPE_FINE_TUNING" },
  { no: 7, name: "ACTIVITY_TYPE_VALIDATION" },
  { no: 8, name: "ACTIVITY_TYPE_DEPLOYMENT" },
  { no: 9, name: "ACTIVITY_TYPE_INFERENCE" },
]);

/**
 * Describes the physical provider of energy used for model development or operations.
 *
 * @generated from message cyclonedx.v1_6.EnergyProviderType
 */
export class EnergyProviderType extends Message<EnergyProviderType> {
  /**
   * BOM unique reference to the energy provider.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * A description of the energy provider.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The organization of the energy provider.
   *
   * @generated from field: cyclonedx.v1_6.OrganizationalEntity organization = 3;
   */
  organization?: OrganizationalEntity;

  /**
   * The energy source for the energy provider.
   *
   * @generated from field: cyclonedx.v1_6.EnergyProviderType.EnergySourceType energySource = 4;
   */
  energySource = EnergyProviderType_EnergySourceType.UNSPECIFIED;

  /**
   * The energy provided by the energy source for an associated activity.
   *
   * @generated from field: cyclonedx.v1_6.EnergyMeasureType energyProvided = 5;
   */
  energyProvided?: EnergyMeasureType;

  /**
   * Provides the ability to document external references related to the BOM or to the project the BOM describes.
   *
   * @generated from field: repeated cyclonedx.v1_6.ExternalReference external_references = 6;
   */
  externalReferences: ExternalReference[] = [];

  constructor(data?: PartialMessage<EnergyProviderType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.EnergyProviderType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "organization", kind: "message", T: OrganizationalEntity },
    { no: 4, name: "energySource", kind: "enum", T: proto3.getEnumType(EnergyProviderType_EnergySourceType) },
    { no: 5, name: "energyProvided", kind: "message", T: EnergyMeasureType },
    { no: 6, name: "external_references", kind: "message", T: ExternalReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnergyProviderType {
    return new EnergyProviderType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnergyProviderType {
    return new EnergyProviderType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnergyProviderType {
    return new EnergyProviderType().fromJsonString(jsonString, options);
  }

  static equals(a: EnergyProviderType | PlainMessage<EnergyProviderType> | undefined, b: EnergyProviderType | PlainMessage<EnergyProviderType> | undefined): boolean {
    return proto3.util.equals(EnergyProviderType, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.EnergyProviderType.EnergySourceType
 */
export enum EnergyProviderType_EnergySourceType {
  /**
   * @generated from enum value: ENERGY_SOURCE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * energy source: unknown. The energy source is unknown.
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * energy source: other. An energy source that is not listed.
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_OTHER = 2;
   */
  OTHER = 2,

  /**
   * energy source: coal. Energy produced by types of coal.
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_COAL = 3;
   */
  COAL = 3,

  /**
   * energy source: oil. Petroleum products (primarily crude oil and its derivative fuel oils).
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_OIL = 4;
   */
  OIL = 4,

  /**
   * energy source: natural-gas. Hydrocarbon gas liquids (HGL) that occur as gases at atmospheric pressure and as liquids under higher pressures including Natural gas (C5H12 and heavier), Ethane (C2H6), Propane (C3H8), etc.
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_NATURAL_GAS = 5;
   */
  NATURAL_GAS = 5,

  /**
   * energy source: nuclear. Energy produced from the cores of atoms (i.e., through nuclear fission or fusion).
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_NUCLEAR = 6;
   */
  NUCLEAR = 6,

  /**
   * energy source: wind. Energy produced from moving air.
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_WIND = 7;
   */
  WIND = 7,

  /**
   * energy source: solar. Energy produced from the sun (i.e., solar radiation).
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_SOLAR = 8;
   */
  SOLAR = 8,

  /**
   * energy source: geothermal. Energy produced from heat within the earth.
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_GEOTHERMAL = 9;
   */
  GEOTHERMAL = 9,

  /**
   * energy source: hydropower. Energy produced from flowing water.
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_HYDROPOWER = 10;
   */
  HYDROPOWER = 10,

  /**
   * energy source: biofuel. Liquid fuels produced from biomass feedstocks (i.e., organic materials such as plants or animals).
   *
   * @generated from enum value: ENERGY_SOURCE_TYPE_BIOFUEL = 11;
   */
  BIOFUEL = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(EnergyProviderType_EnergySourceType)
proto3.util.setEnumType(EnergyProviderType_EnergySourceType, "cyclonedx.v1_6.EnergyProviderType.EnergySourceType", [
  { no: 0, name: "ENERGY_SOURCE_TYPE_UNSPECIFIED" },
  { no: 1, name: "ENERGY_SOURCE_TYPE_UNKNOWN" },
  { no: 2, name: "ENERGY_SOURCE_TYPE_OTHER" },
  { no: 3, name: "ENERGY_SOURCE_TYPE_COAL" },
  { no: 4, name: "ENERGY_SOURCE_TYPE_OIL" },
  { no: 5, name: "ENERGY_SOURCE_TYPE_NATURAL_GAS" },
  { no: 6, name: "ENERGY_SOURCE_TYPE_NUCLEAR" },
  { no: 7, name: "ENERGY_SOURCE_TYPE_WIND" },
  { no: 8, name: "ENERGY_SOURCE_TYPE_SOLAR" },
  { no: 9, name: "ENERGY_SOURCE_TYPE_GEOTHERMAL" },
  { no: 10, name: "ENERGY_SOURCE_TYPE_HYDROPOWER" },
  { no: 11, name: "ENERGY_SOURCE_TYPE_BIOFUEL" },
]);

/**
 * A measure of energy.
 *
 * @generated from message cyclonedx.v1_6.EnergyMeasureType
 */
export class EnergyMeasureType extends Message<EnergyMeasureType> {
  /**
   * Quantity of energy.
   *
   * @generated from field: float value = 1;
   */
  value = 0;

  /**
   * Unit of energy.
   *
   * @generated from field: cyclonedx.v1_6.EnergyMeasureType.EnergyMeasureUnitType unit = 2;
   */
  unit = EnergyMeasureType_EnergyMeasureUnitType.UNSPECIFIED;

  constructor(data?: PartialMessage<EnergyMeasureType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.EnergyMeasureType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "unit", kind: "enum", T: proto3.getEnumType(EnergyMeasureType_EnergyMeasureUnitType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnergyMeasureType {
    return new EnergyMeasureType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnergyMeasureType {
    return new EnergyMeasureType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnergyMeasureType {
    return new EnergyMeasureType().fromJsonString(jsonString, options);
  }

  static equals(a: EnergyMeasureType | PlainMessage<EnergyMeasureType> | undefined, b: EnergyMeasureType | PlainMessage<EnergyMeasureType> | undefined): boolean {
    return proto3.util.equals(EnergyMeasureType, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.EnergyMeasureType.EnergyMeasureUnitType
 */
export enum EnergyMeasureType_EnergyMeasureUnitType {
  /**
   * @generated from enum value: ENERGY_MEASURE_UNIT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * kilowatt-hour (kWh) is the energy delivered by one kilowatt (kW) of power for one hour (h) (the default unit).
   *
   * @generated from enum value: ENERGY_MEASURE_UNIT_TYPE_KILOWATT_HOURS = 1;
   */
  KILOWATT_HOURS = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(EnergyMeasureType_EnergyMeasureUnitType)
proto3.util.setEnumType(EnergyMeasureType_EnergyMeasureUnitType, "cyclonedx.v1_6.EnergyMeasureType.EnergyMeasureUnitType", [
  { no: 0, name: "ENERGY_MEASURE_UNIT_TYPE_UNSPECIFIED" },
  { no: 1, name: "ENERGY_MEASURE_UNIT_TYPE_KILOWATT_HOURS" },
]);

/**
 * A measure of carbon dioxide (CO2).
 *
 * @generated from message cyclonedx.v1_6.CO2MeasureType
 */
export class CO2MeasureType extends Message<CO2MeasureType> {
  /**
   * Quantity of carbon dioxide (CO2).
   *
   * @generated from field: float value = 1;
   */
  value = 0;

  /**
   * Unit of carbon dioxide (CO2).
   *
   * @generated from field: cyclonedx.v1_6.CO2MeasureType.CO2MeasureUnitType unit = 2;
   */
  unit = CO2MeasureType_CO2MeasureUnitType.CO2_MEASURE_UNIT_TYPE_UNSPECIFIED;

  constructor(data?: PartialMessage<CO2MeasureType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.CO2MeasureType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "unit", kind: "enum", T: proto3.getEnumType(CO2MeasureType_CO2MeasureUnitType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CO2MeasureType {
    return new CO2MeasureType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CO2MeasureType {
    return new CO2MeasureType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CO2MeasureType {
    return new CO2MeasureType().fromJsonString(jsonString, options);
  }

  static equals(a: CO2MeasureType | PlainMessage<CO2MeasureType> | undefined, b: CO2MeasureType | PlainMessage<CO2MeasureType> | undefined): boolean {
    return proto3.util.equals(CO2MeasureType, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.CO2MeasureType.CO2MeasureUnitType
 */
export enum CO2MeasureType_CO2MeasureUnitType {
  /**
   * @generated from enum value: CO2_MEASURE_UNIT_TYPE_UNSPECIFIED = 0;
   */
  CO2_MEASURE_UNIT_TYPE_UNSPECIFIED = 0,

  /**
   * Tonnes (t) of carbon dioxide (CO2) equivalent (eq) (the default unit).
   *
   * @generated from enum value: CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT = 1;
   */
  CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(CO2MeasureType_CO2MeasureUnitType)
proto3.util.setEnumType(CO2MeasureType_CO2MeasureUnitType, "cyclonedx.v1_6.CO2MeasureType.CO2MeasureUnitType", [
  { no: 0, name: "CO2_MEASURE_UNIT_TYPE_UNSPECIFIED" },
  { no: 1, name: "CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT" },
]);

/**
 * An address used to identify a contactable location.
 *
 * @generated from message cyclonedx.v1_6.PostalAddressType
 */
export class PostalAddressType extends Message<PostalAddressType> {
  /**
   * An optional identifier which can be used to reference the address elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The country name or the two-letter ISO 3166-1 country code.
   *
   * @generated from field: optional string country = 2;
   */
  country?: string;

  /**
   * The region or state in the country. For example, Texas.
   *
   * @generated from field: optional string region = 3;
   */
  region?: string;

  /**
   * The locality or city within the country. For example, Austin.
   *
   * @generated from field: optional string locality = 4;
   */
  locality?: string;

  /**
   * The post office box number. For example, 901.
   *
   * @generated from field: optional string postOfficeBoxNumber = 5;
   */
  postOfficeBoxNumber?: string;

  /**
   * The postal code. For example, 78758.
   *
   * @generated from field: optional string postalCodeue = 6;
   */
  postalCodeue?: string;

  /**
   * The street address. For example, 100 Main Street.
   *
   * @generated from field: optional string streetAddress = 7;
   */
  streetAddress?: string;

  constructor(data?: PartialMessage<PostalAddressType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.PostalAddressType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "locality", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "postOfficeBoxNumber", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "postalCodeue", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "streetAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostalAddressType {
    return new PostalAddressType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostalAddressType {
    return new PostalAddressType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostalAddressType {
    return new PostalAddressType().fromJsonString(jsonString, options);
  }

  static equals(a: PostalAddressType | PlainMessage<PostalAddressType> | undefined, b: PostalAddressType | PlainMessage<PostalAddressType> | undefined): boolean {
    return proto3.util.equals(PostalAddressType, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ComponentData
 */
export class ComponentData extends Message<ComponentData> {
  /**
   * An optional identifier which can be used to reference the dataset elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The general theme or subject matter of the data being specified.
   *
   * @generated from field: cyclonedx.v1_6.ComponentDataType type = 2;
   */
  type = ComponentDataType.SOURCE_CODE;

  /**
   * The name of the dataset.
   *
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * The contents or references to the contents of the data being described.
   *
   * @generated from field: optional cyclonedx.v1_6.ComponentData.ComponentDataContents contents = 4;
   */
  contents?: ComponentData_ComponentDataContents;

  /**
   * Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed.
   *
   * @generated from field: optional string classification = 5;
   */
  classification?: string;

  /**
   * A description of any sensitive data in a dataset.
   *
   * @generated from field: repeated string sensitiveData = 6;
   */
  sensitiveData: string[] = [];

  /**
   * A collection of graphics that represent various measurements.
   *
   * @generated from field: optional cyclonedx.v1_6.GraphicsCollection graphics = 7;
   */
  graphics?: GraphicsCollection;

  /**
   * A description of the dataset. Can describe size of dataset, whether it's used for source code, training, testing, or validation, etc.
   *
   * @generated from field: optional string description = 8;
   */
  description?: string;

  /**
   * Data Governance
   *
   * @generated from field: optional cyclonedx.v1_6.DataGovernance governance = 9;
   */
  governance?: DataGovernance;

  constructor(data?: PartialMessage<ComponentData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ComponentData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ComponentDataType) },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "contents", kind: "message", T: ComponentData_ComponentDataContents, opt: true },
    { no: 5, name: "classification", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "sensitiveData", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "graphics", kind: "message", T: GraphicsCollection, opt: true },
    { no: 8, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "governance", kind: "message", T: DataGovernance, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComponentData {
    return new ComponentData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComponentData {
    return new ComponentData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComponentData {
    return new ComponentData().fromJsonString(jsonString, options);
  }

  static equals(a: ComponentData | PlainMessage<ComponentData> | undefined, b: ComponentData | PlainMessage<ComponentData> | undefined): boolean {
    return proto3.util.equals(ComponentData, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.ComponentData.ComponentDataContents
 */
export class ComponentData_ComponentDataContents extends Message<ComponentData_ComponentDataContents> {
  /**
   * An optional way to include textual or encoded data.
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText attachment = 1;
   */
  attachment?: AttachedText;

  /**
   * The URL to where the data can be retrieved.
   *
   * @generated from field: optional string url = 2;
   */
  url?: string;

  /**
   * Provides the ability to document name-value parameters used for configuration.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 3;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<ComponentData_ComponentDataContents>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ComponentData.ComponentDataContents";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attachment", kind: "message", T: AttachedText, opt: true },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComponentData_ComponentDataContents {
    return new ComponentData_ComponentDataContents().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComponentData_ComponentDataContents {
    return new ComponentData_ComponentDataContents().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComponentData_ComponentDataContents {
    return new ComponentData_ComponentDataContents().fromJsonString(jsonString, options);
  }

  static equals(a: ComponentData_ComponentDataContents | PlainMessage<ComponentData_ComponentDataContents> | undefined, b: ComponentData_ComponentDataContents | PlainMessage<ComponentData_ComponentDataContents> | undefined): boolean {
    return proto3.util.equals(ComponentData_ComponentDataContents, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.DataGovernance
 */
export class DataGovernance extends Message<DataGovernance> {
  /**
   * Data custodians are responsible for the safe custody, transport, and storage of data.
   *
   * @generated from field: repeated cyclonedx.v1_6.DataGovernance.DataGovernanceResponsibleParty custodians = 1;
   */
  custodians: DataGovernance_DataGovernanceResponsibleParty[] = [];

  /**
   * Data stewards are responsible for data content, context, and associated business rules.
   *
   * @generated from field: repeated cyclonedx.v1_6.DataGovernance.DataGovernanceResponsibleParty stewards = 2;
   */
  stewards: DataGovernance_DataGovernanceResponsibleParty[] = [];

  /**
   * Data owners are concerned with risk and appropriate access to data.
   *
   * @generated from field: repeated cyclonedx.v1_6.DataGovernance.DataGovernanceResponsibleParty owners = 3;
   */
  owners: DataGovernance_DataGovernanceResponsibleParty[] = [];

  constructor(data?: PartialMessage<DataGovernance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.DataGovernance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "custodians", kind: "message", T: DataGovernance_DataGovernanceResponsibleParty, repeated: true },
    { no: 2, name: "stewards", kind: "message", T: DataGovernance_DataGovernanceResponsibleParty, repeated: true },
    { no: 3, name: "owners", kind: "message", T: DataGovernance_DataGovernanceResponsibleParty, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataGovernance {
    return new DataGovernance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataGovernance {
    return new DataGovernance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataGovernance {
    return new DataGovernance().fromJsonString(jsonString, options);
  }

  static equals(a: DataGovernance | PlainMessage<DataGovernance> | undefined, b: DataGovernance | PlainMessage<DataGovernance> | undefined): boolean {
    return proto3.util.equals(DataGovernance, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.DataGovernance.DataGovernanceResponsibleParty
 */
export class DataGovernance_DataGovernanceResponsibleParty extends Message<DataGovernance_DataGovernanceResponsibleParty> {
  /**
   * @generated from oneof cyclonedx.v1_6.DataGovernance.DataGovernanceResponsibleParty.choice
   */
  choice: {
    /**
     * @generated from field: cyclonedx.v1_6.OrganizationalEntity organization = 1;
     */
    value: OrganizationalEntity;
    case: "organization";
  } | {
    /**
     * @generated from field: cyclonedx.v1_6.OrganizationalContact contact = 2;
     */
    value: OrganizationalContact;
    case: "contact";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DataGovernance_DataGovernanceResponsibleParty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.DataGovernance.DataGovernanceResponsibleParty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "organization", kind: "message", T: OrganizationalEntity, oneof: "choice" },
    { no: 2, name: "contact", kind: "message", T: OrganizationalContact, oneof: "choice" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataGovernance_DataGovernanceResponsibleParty {
    return new DataGovernance_DataGovernanceResponsibleParty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataGovernance_DataGovernanceResponsibleParty {
    return new DataGovernance_DataGovernanceResponsibleParty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataGovernance_DataGovernanceResponsibleParty {
    return new DataGovernance_DataGovernanceResponsibleParty().fromJsonString(jsonString, options);
  }

  static equals(a: DataGovernance_DataGovernanceResponsibleParty | PlainMessage<DataGovernance_DataGovernanceResponsibleParty> | undefined, b: DataGovernance_DataGovernanceResponsibleParty | PlainMessage<DataGovernance_DataGovernanceResponsibleParty> | undefined): boolean {
    return proto3.util.equals(DataGovernance_DataGovernanceResponsibleParty, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.GraphicsCollection
 */
export class GraphicsCollection extends Message<GraphicsCollection> {
  /**
   * A description of this collection of graphics.
   *
   * @generated from field: optional string description = 1;
   */
  description?: string;

  /**
   * A collection of graphics.
   *
   * @generated from field: repeated cyclonedx.v1_6.GraphicsCollection.Graphic graphic = 2;
   */
  graphic: GraphicsCollection_Graphic[] = [];

  constructor(data?: PartialMessage<GraphicsCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.GraphicsCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "graphic", kind: "message", T: GraphicsCollection_Graphic, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GraphicsCollection {
    return new GraphicsCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GraphicsCollection {
    return new GraphicsCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GraphicsCollection {
    return new GraphicsCollection().fromJsonString(jsonString, options);
  }

  static equals(a: GraphicsCollection | PlainMessage<GraphicsCollection> | undefined, b: GraphicsCollection | PlainMessage<GraphicsCollection> | undefined): boolean {
    return proto3.util.equals(GraphicsCollection, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.GraphicsCollection.Graphic
 */
export class GraphicsCollection_Graphic extends Message<GraphicsCollection_Graphic> {
  /**
   * The name of the graphic.
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * The graphic (vector or raster). Base64 encoding MUST be specified for binary images.
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText image = 2;
   */
  image?: AttachedText;

  constructor(data?: PartialMessage<GraphicsCollection_Graphic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.GraphicsCollection.Graphic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "image", kind: "message", T: AttachedText, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GraphicsCollection_Graphic {
    return new GraphicsCollection_Graphic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GraphicsCollection_Graphic {
    return new GraphicsCollection_Graphic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GraphicsCollection_Graphic {
    return new GraphicsCollection_Graphic().fromJsonString(jsonString, options);
  }

  static equals(a: GraphicsCollection_Graphic | PlainMessage<GraphicsCollection_Graphic> | undefined, b: GraphicsCollection_Graphic | PlainMessage<GraphicsCollection_Graphic> | undefined): boolean {
    return proto3.util.equals(GraphicsCollection_Graphic, a, b);
  }
}

/**
 * Describes workflows and resources that captures rules and other aspects of how the associated BOM component or service was formed.
 *
 * @generated from message cyclonedx.v1_6.Formula
 */
export class Formula extends Message<Formula> {
  /**
   * BOM unique reference to the resource.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * Transient components that are used in tasks that constitute one or more of this formula's workflows
   *
   * @generated from field: repeated cyclonedx.v1_6.Component components = 2;
   */
  components: Component[] = [];

  /**
   * Transient services that are used in tasks that constitute one or more of this formula's workflows
   *
   * @generated from field: repeated cyclonedx.v1_6.Service services = 3;
   */
  services: Service[] = [];

  /**
   * List of workflows that can be declared to accomplish specific orchestrated goals and independently triggered.
   *
   * @generated from field: repeated cyclonedx.v1_6.Workflow workflows = 4;
   */
  workflows: Workflow[] = [];

  /**
   * Domain-specific formula properties.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 5;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<Formula>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Formula";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "components", kind: "message", T: Component, repeated: true },
    { no: 3, name: "services", kind: "message", T: Service, repeated: true },
    { no: 4, name: "workflows", kind: "message", T: Workflow, repeated: true },
    { no: 5, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Formula {
    return new Formula().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Formula {
    return new Formula().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Formula {
    return new Formula().fromJsonString(jsonString, options);
  }

  static equals(a: Formula | PlainMessage<Formula> | undefined, b: Formula | PlainMessage<Formula> | undefined): boolean {
    return proto3.util.equals(Formula, a, b);
  }
}

/**
 * A specialized orchestration task.
 *
 * @generated from message cyclonedx.v1_6.Workflow
 */
export class Workflow extends Message<Workflow> {
  /**
   * BOM unique reference to the resource.
   *
   * @generated from field: string bom_ref = 1;
   */
  bomRef = "";

  /**
   * The unique identifier for the resource instance within its deployment context.
   *
   * @generated from field: string uid = 2;
   */
  uid = "";

  /**
   * The name of the resource instance.
   *
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * A description of the resource instance.
   *
   * @generated from field: optional string description = 4;
   */
  description?: string;

  /**
   * Domain-specific resource instance properties.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 5;
   */
  properties: Property[] = [];

  /**
   * References to component or service resources that are used to realize the resource instance.
   *
   * @generated from field: repeated cyclonedx.v1_6.ResourceReferenceChoice resourceReferences = 6;
   */
  resourceReferences: ResourceReferenceChoice[] = [];

  /**
   * The tasks that comprise the workflow.
   *
   * @generated from field: repeated cyclonedx.v1_6.Task tasks = 7;
   */
  tasks: Task[] = [];

  /**
   * The graph of dependencies between tasks within the workflow.
   *
   * @generated from field: repeated cyclonedx.v1_6.Dependency taskDependencies = 8;
   */
  taskDependencies: Dependency[] = [];

  /**
   * Indicates the types of activities performed by the set of workflow tasks.
   *
   * @generated from field: repeated cyclonedx.v1_6.TaskType taskTypes = 9;
   */
  taskTypes: TaskType[] = [];

  /**
   * The trigger that initiated the task.
   *
   * @generated from field: optional cyclonedx.v1_6.Trigger trigger = 10;
   */
  trigger?: Trigger;

  /**
   * The sequence of steps for the task.
   *
   * @generated from field: repeated cyclonedx.v1_6.Step steps = 11;
   */
  steps: Step[] = [];

  /**
   * Represents resources and data brought into a task at runtime by executor or task commands
   *
   * @generated from field: repeated cyclonedx.v1_6.InputType inputs = 12;
   */
  inputs: InputType[] = [];

  /**
   * Represents resources and data output from a task at runtime by executor or task commands
   *
   * @generated from field: repeated cyclonedx.v1_6.OutputType outputs = 13;
   */
  outputs: OutputType[] = [];

  /**
   * The date and time (timestamp) when the task started.
   *
   * @generated from field: optional google.protobuf.Timestamp timeStart = 14;
   */
  timeStart?: Timestamp;

  /**
   * The date and time (timestamp) when the task ended.
   *
   * @generated from field: optional google.protobuf.Timestamp timeEnd = 15;
   */
  timeEnd?: Timestamp;

  /**
   * A set of named filesystem or data resource shareable by workflow tasks.
   *
   * @generated from field: repeated cyclonedx.v1_6.Workspace workspaces = 16;
   */
  workspaces: Workspace[] = [];

  /**
   * A graph of the component runtime topology for workflow's instance.
   *
   * @generated from field: repeated cyclonedx.v1_6.Dependency runtimeTopology = 17;
   */
  runtimeTopology: Dependency[] = [];

  constructor(data?: PartialMessage<Workflow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Workflow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 6, name: "resourceReferences", kind: "message", T: ResourceReferenceChoice, repeated: true },
    { no: 7, name: "tasks", kind: "message", T: Task, repeated: true },
    { no: 8, name: "taskDependencies", kind: "message", T: Dependency, repeated: true },
    { no: 9, name: "taskTypes", kind: "enum", T: proto3.getEnumType(TaskType), repeated: true },
    { no: 10, name: "trigger", kind: "message", T: Trigger, opt: true },
    { no: 11, name: "steps", kind: "message", T: Step, repeated: true },
    { no: 12, name: "inputs", kind: "message", T: InputType, repeated: true },
    { no: 13, name: "outputs", kind: "message", T: OutputType, repeated: true },
    { no: 14, name: "timeStart", kind: "message", T: Timestamp, opt: true },
    { no: 15, name: "timeEnd", kind: "message", T: Timestamp, opt: true },
    { no: 16, name: "workspaces", kind: "message", T: Workspace, repeated: true },
    { no: 17, name: "runtimeTopology", kind: "message", T: Dependency, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Workflow {
    return new Workflow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Workflow {
    return new Workflow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Workflow {
    return new Workflow().fromJsonString(jsonString, options);
  }

  static equals(a: Workflow | PlainMessage<Workflow> | undefined, b: Workflow | PlainMessage<Workflow> | undefined): boolean {
    return proto3.util.equals(Workflow, a, b);
  }
}

/**
 * Describes the inputs, sequence of steps and resources used to accomplish a task and its output.
 *
 * @generated from message cyclonedx.v1_6.Task
 */
export class Task extends Message<Task> {
  /**
   * BOM unique reference to the resource.
   *
   * @generated from field: string bom_ref = 1;
   */
  bomRef = "";

  /**
   * The unique identifier for the resource instance within its deployment context.
   *
   * @generated from field: string uid = 2;
   */
  uid = "";

  /**
   * The name of the resource instance.
   *
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * A description of the resource instance.
   *
   * @generated from field: optional string description = 4;
   */
  description?: string;

  /**
   * Domain-specific task instance properties.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 5;
   */
  properties: Property[] = [];

  /**
   * References to component or service resources that are used to realize the resource instance.
   *
   * @generated from field: repeated cyclonedx.v1_6.ResourceReferenceChoice resourceReferences = 6;
   */
  resourceReferences: ResourceReferenceChoice[] = [];

  /**
   * Indicates the types of activities performed by the set of workflow tasks.
   *
   * @generated from field: repeated cyclonedx.v1_6.TaskType taskTypes = 7;
   */
  taskTypes: TaskType[] = [];

  /**
   * The trigger that initiated the task.
   *
   * @generated from field: optional cyclonedx.v1_6.Trigger trigger = 8;
   */
  trigger?: Trigger;

  /**
   * "The sequence of steps for the task.
   *
   * @generated from field: repeated cyclonedx.v1_6.Step steps = 9;
   */
  steps: Step[] = [];

  /**
   * Represents resources and data brought into a task at runtime by an executor or task commands
   *
   * @generated from field: repeated cyclonedx.v1_6.InputType inputs = 10;
   */
  inputs: InputType[] = [];

  /**
   * Represents resources and data output from a task at runtime by an executor or task commands
   *
   * @generated from field: repeated cyclonedx.v1_6.OutputType outputs = 11;
   */
  outputs: OutputType[] = [];

  /**
   * The date and time (timestamp) when the task started.
   *
   * @generated from field: optional google.protobuf.Timestamp timeStart = 14;
   */
  timeStart?: Timestamp;

  /**
   * The date and time (timestamp) when the task ended.
   *
   * @generated from field: optional google.protobuf.Timestamp timeEnd = 15;
   */
  timeEnd?: Timestamp;

  /**
   * A set of named filesystem or data resource shareable by workflow tasks.
   *
   * @generated from field: repeated cyclonedx.v1_6.Workspace workspaces = 16;
   */
  workspaces: Workspace[] = [];

  /**
   * A graph of the component runtime topology for task's instance.
   *
   * @generated from field: repeated cyclonedx.v1_6.Dependency runtimeTopology = 17;
   */
  runtimeTopology: Dependency[] = [];

  constructor(data?: PartialMessage<Task>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Task";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 6, name: "resourceReferences", kind: "message", T: ResourceReferenceChoice, repeated: true },
    { no: 7, name: "taskTypes", kind: "enum", T: proto3.getEnumType(TaskType), repeated: true },
    { no: 8, name: "trigger", kind: "message", T: Trigger, opt: true },
    { no: 9, name: "steps", kind: "message", T: Step, repeated: true },
    { no: 10, name: "inputs", kind: "message", T: InputType, repeated: true },
    { no: 11, name: "outputs", kind: "message", T: OutputType, repeated: true },
    { no: 14, name: "timeStart", kind: "message", T: Timestamp, opt: true },
    { no: 15, name: "timeEnd", kind: "message", T: Timestamp, opt: true },
    { no: 16, name: "workspaces", kind: "message", T: Workspace, repeated: true },
    { no: 17, name: "runtimeTopology", kind: "message", T: Dependency, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Task {
    return new Task().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Task {
    return new Task().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Task {
    return new Task().fromJsonString(jsonString, options);
  }

  static equals(a: Task | PlainMessage<Task> | undefined, b: Task | PlainMessage<Task> | undefined): boolean {
    return proto3.util.equals(Task, a, b);
  }
}

/**
 * Executes specific commands or tools in order to accomplish its owning task as part of a sequence.
 *
 * @generated from message cyclonedx.v1_6.Step
 */
export class Step extends Message<Step> {
  /**
   * A name for the step.
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * A description of the step.
   *
   * @generated from field: optional string description = 2;
   */
  description?: string;

  /**
   * Ordered list of commands or directives for the step
   *
   * @generated from field: repeated cyclonedx.v1_6.Command commands = 3;
   */
  commands: Command[] = [];

  /**
   * Domain-specific step properties.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 4;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<Step>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Step";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "commands", kind: "message", T: Command, repeated: true },
    { no: 4, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Step {
    return new Step().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Step {
    return new Step().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Step {
    return new Step().fromJsonString(jsonString, options);
  }

  static equals(a: Step | PlainMessage<Step> | undefined, b: Step | PlainMessage<Step> | undefined): boolean {
    return proto3.util.equals(Step, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Command
 */
export class Command extends Message<Command> {
  /**
   * A text representation of the executed command.
   *
   * @generated from field: optional string executed = 1;
   */
  executed?: string;

  /**
   * Domain-specific command properties.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 2;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<Command>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Command";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "executed", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Command {
    return new Command().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Command {
    return new Command().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Command {
    return new Command().fromJsonString(jsonString, options);
  }

  static equals(a: Command | PlainMessage<Command> | undefined, b: Command | PlainMessage<Command> | undefined): boolean {
    return proto3.util.equals(Command, a, b);
  }
}

/**
 * A named filesystem or data resource shareable by workflow tasks.
 *
 * @generated from message cyclonedx.v1_6.Workspace
 */
export class Workspace extends Message<Workspace> {
  /**
   * BOM unique reference to the resource.
   *
   * @generated from field: string bom_ref = 1;
   */
  bomRef = "";

  /**
   * The unique identifier for the resource instance within its deployment context.
   *
   * @generated from field: string uid = 2;
   */
  uid = "";

  /**
   * The name of the resource instance.
   *
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * The names for the workspace as referenced by other workflow tasks. Effectively, a name mapping so other tasks can use their own local name in their steps.
   *
   * @generated from field: repeated string aliases = 4;
   */
  aliases: string[] = [];

  /**
   * A description of the resource instance.
   *
   * @generated from field: optional string description = 5;
   */
  description?: string;

  /**
   * Domain-specific workspace instance properties.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 6;
   */
  properties: Property[] = [];

  /**
   * References to component or service resources that are used to realize the resource instance.
   *
   * @generated from field: repeated cyclonedx.v1_6.ResourceReferenceChoice resourceReferences = 7;
   */
  resourceReferences: ResourceReferenceChoice[] = [];

  /**
   * Describes the read-write access control for the workspace relative to the owning resource instance.
   *
   * @generated from field: optional cyclonedx.v1_6.Workspace.AccessMode accessMode = 8;
   */
  accessMode?: Workspace_AccessMode;

  /**
   * A path to a location on disk where the workspace will be available for the associated task's steps.
   *
   * @generated from field: optional string mountPath = 9;
   */
  mountPath?: string;

  /**
   * The name of a domain-specific data type the workspace represents.
   *
   * @generated from field: optional string managedDataType = 10;
   */
  managedDataType?: string;

  /**
   * Identifies the reference to the request for a specific volume type and parameters.
   *
   * @generated from field: optional string volumeRequest = 11;
   */
  volumeRequest?: string;

  /**
   * Information about the actual volume instance allocated to the workspace.
   *
   * @generated from field: optional cyclonedx.v1_6.Volume volume = 12;
   */
  volume?: Volume;

  constructor(data?: PartialMessage<Workspace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Workspace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "aliases", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 7, name: "resourceReferences", kind: "message", T: ResourceReferenceChoice, repeated: true },
    { no: 8, name: "accessMode", kind: "enum", T: proto3.getEnumType(Workspace_AccessMode), opt: true },
    { no: 9, name: "mountPath", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "managedDataType", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "volumeRequest", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 12, name: "volume", kind: "message", T: Volume, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Workspace {
    return new Workspace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Workspace {
    return new Workspace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Workspace {
    return new Workspace().fromJsonString(jsonString, options);
  }

  static equals(a: Workspace | PlainMessage<Workspace> | undefined, b: Workspace | PlainMessage<Workspace> | undefined): boolean {
    return proto3.util.equals(Workspace, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.Workspace.AccessMode
 */
export enum Workspace_AccessMode {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
   *
   * @generated from enum value: ACCESS_MODE_READ_ONLY = 0;
   */
  READ_ONLY = 0,

  /**
   * @generated from enum value: ACCESS_MODE_READ_WRITE = 1;
   */
  READ_WRITE = 1,

  /**
   * @generated from enum value: ACCESS_MODE_READ_WRITE_ONCE = 2;
   */
  READ_WRITE_ONCE = 2,

  /**
   * @generated from enum value: ACCESS_MODE_WRITE_ONCE = 3;
   */
  WRITE_ONCE = 3,

  /**
   * @generated from enum value: ACCESS_MODE_WRITE_ONLY = 4;
   */
  WRITE_ONLY = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Workspace_AccessMode)
proto3.util.setEnumType(Workspace_AccessMode, "cyclonedx.v1_6.Workspace.AccessMode", [
  { no: 0, name: "ACCESS_MODE_READ_ONLY" },
  { no: 1, name: "ACCESS_MODE_READ_WRITE" },
  { no: 2, name: "ACCESS_MODE_READ_WRITE_ONCE" },
  { no: 3, name: "ACCESS_MODE_WRITE_ONCE" },
  { no: 4, name: "ACCESS_MODE_WRITE_ONLY" },
]);

/**
 * An identifiable, logical unit of data storage tied to a physical device.
 *
 * @generated from message cyclonedx.v1_6.Volume
 */
export class Volume extends Message<Volume> {
  /**
   * The unique identifier for the volume instance within its deployment context.
   *
   * @generated from field: optional string uid = 1;
   */
  uid?: string;

  /**
   * The name of the volume instance
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * The volume mode for the volume instance.
   *
   * @generated from field: optional cyclonedx.v1_6.Volume.VolumeMode mode = 3;
   */
  mode?: Volume_VolumeMode;

  /**
   * The underlying path created from the actual volume.
   *
   * @generated from field: optional string path = 4;
   */
  path?: string;

  /**
   * The allocated size of the volume accessible to the associated workspace. This should include the scalar size as well as the IEC standard unit in either decimal or binary form.
   *
   * @generated from field: optional string sizeAllocated = 5;
   */
  sizeAllocated?: string;

  /**
   * Indicates if the volume persists beyond the life of the resource it is associated with.
   *
   * @generated from field: optional bool persistent = 6;
   */
  persistent?: boolean;

  /**
   * Indicates if the volume is remotely (i.e., network) attached.
   *
   * @generated from field: optional bool remote = 7;
   */
  remote?: boolean;

  /**
   * Domain-specific volume instance properties.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 8;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<Volume>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Volume";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "mode", kind: "enum", T: proto3.getEnumType(Volume_VolumeMode), opt: true },
    { no: 4, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "sizeAllocated", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "persistent", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "remote", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 8, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Volume {
    return new Volume().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Volume {
    return new Volume().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Volume {
    return new Volume().fromJsonString(jsonString, options);
  }

  static equals(a: Volume | PlainMessage<Volume> | undefined, b: Volume | PlainMessage<Volume> | undefined): boolean {
    return proto3.util.equals(Volume, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.Volume.VolumeMode
 */
export enum Volume_VolumeMode {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
   *
   * @generated from enum value: VOLUME_MODE_FILESYSTEM = 0;
   */
  FILESYSTEM = 0,

  /**
   * @generated from enum value: VOLUME_MODE_BLOCK = 1;
   */
  BLOCK = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Volume_VolumeMode)
proto3.util.setEnumType(Volume_VolumeMode, "cyclonedx.v1_6.Volume.VolumeMode", [
  { no: 0, name: "VOLUME_MODE_FILESYSTEM" },
  { no: 1, name: "VOLUME_MODE_BLOCK" },
]);

/**
 * Represents a resource that can conditionally activate (or fire) tasks based upon associated events and their data.
 *
 * @generated from message cyclonedx.v1_6.Trigger
 */
export class Trigger extends Message<Trigger> {
  /**
   * BOM unique reference to the resource.
   *
   * @generated from field: string bom_ref = 1;
   */
  bomRef = "";

  /**
   * The unique identifier for the resource instance within its deployment context.
   *
   * @generated from field: string uid = 2;
   */
  uid = "";

  /**
   * The name of the resource instance.
   *
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * A description of the resource instance.
   *
   * @generated from field: optional string description = 4;
   */
  description?: string;

  /**
   * Additional properties of the trigger.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 5;
   */
  properties: Property[] = [];

  /**
   * References to component or service resources that are used to realize the resource instance.
   *
   * @generated from field: repeated cyclonedx.v1_6.ResourceReferenceChoice resourceReferences = 6;
   */
  resourceReferences: ResourceReferenceChoice[] = [];

  /**
   * The source type of event which caused the trigger to fire.
   *
   * @generated from field: cyclonedx.v1_6.Trigger.TriggerType type = 7;
   */
  type = Trigger_TriggerType.MANUAL;

  /**
   * The event data that caused the associated trigger to activate.
   *
   * @generated from field: optional cyclonedx.v1_6.Event event = 8;
   */
  event?: Event;

  /**
   * Conditions
   *
   * @generated from field: repeated cyclonedx.v1_6.Condition conditions = 9;
   */
  conditions: Condition[] = [];

  /**
   * The date and time (timestamp) when the trigger was activated.
   *
   * @generated from field: optional google.protobuf.Timestamp timeActivated = 10;
   */
  timeActivated?: Timestamp;

  /**
   * Represents resources and data brought into a task at runtime by an executor or task commands
   *
   * @generated from field: repeated cyclonedx.v1_6.InputType inputs = 11;
   */
  inputs: InputType[] = [];

  /**
   * Represents resources and data output from a task at runtime by an executor or task commands
   *
   * @generated from field: repeated cyclonedx.v1_6.OutputType outputs = 12;
   */
  outputs: OutputType[] = [];

  constructor(data?: PartialMessage<Trigger>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Trigger";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 6, name: "resourceReferences", kind: "message", T: ResourceReferenceChoice, repeated: true },
    { no: 7, name: "type", kind: "enum", T: proto3.getEnumType(Trigger_TriggerType) },
    { no: 8, name: "event", kind: "message", T: Event, opt: true },
    { no: 9, name: "conditions", kind: "message", T: Condition, repeated: true },
    { no: 10, name: "timeActivated", kind: "message", T: Timestamp, opt: true },
    { no: 11, name: "inputs", kind: "message", T: InputType, repeated: true },
    { no: 12, name: "outputs", kind: "message", T: OutputType, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Trigger {
    return new Trigger().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Trigger {
    return new Trigger().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Trigger {
    return new Trigger().fromJsonString(jsonString, options);
  }

  static equals(a: Trigger | PlainMessage<Trigger> | undefined, b: Trigger | PlainMessage<Trigger> | undefined): boolean {
    return proto3.util.equals(Trigger, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.Trigger.TriggerType
 */
export enum Trigger_TriggerType {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
   *
   * @generated from enum value: TRIGGER_TYPE_MANUAL = 0;
   */
  MANUAL = 0,

  /**
   * @generated from enum value: TRIGGER_TYPE_API = 1;
   */
  API = 1,

  /**
   * @generated from enum value: TRIGGER_TYPE_WEBHOOK = 2;
   */
  WEBHOOK = 2,

  /**
   * @generated from enum value: TRIGGER_TYPE_SCHEDULED = 3;
   */
  SCHEDULED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Trigger_TriggerType)
proto3.util.setEnumType(Trigger_TriggerType, "cyclonedx.v1_6.Trigger.TriggerType", [
  { no: 0, name: "TRIGGER_TYPE_MANUAL" },
  { no: 1, name: "TRIGGER_TYPE_API" },
  { no: 2, name: "TRIGGER_TYPE_WEBHOOK" },
  { no: 3, name: "TRIGGER_TYPE_SCHEDULED" },
]);

/**
 * Represents something that happened that may trigger a response.
 *
 * @generated from message cyclonedx.v1_6.Event
 */
export class Event extends Message<Event> {
  /**
   * The unique identifier of the event.
   *
   * @generated from field: optional string uid = 1;
   */
  uid?: string;

  /**
   * A description of the event.
   *
   * @generated from field: optional string description = 2;
   */
  description?: string;

  /**
   * The date and time (timestamp) when the event was received.
   *
   * @generated from field: optional google.protobuf.Timestamp timeReceived = 3;
   */
  timeReceived?: Timestamp;

  /**
   * Encoding of the raw event data.
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText data = 4;
   */
  data?: AttachedText;

  /**
   * References the component or service that was the source of the event
   *
   * @generated from field: optional cyclonedx.v1_6.ResourceReferenceChoice source = 5;
   */
  source?: ResourceReferenceChoice;

  /**
   * References the component or service that was the target of the event
   *
   * @generated from field: optional cyclonedx.v1_6.ResourceReferenceChoice target = 6;
   */
  target?: ResourceReferenceChoice;

  /**
   * Additional properties of the event.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 7;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<Event>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Event";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "timeReceived", kind: "message", T: Timestamp, opt: true },
    { no: 4, name: "data", kind: "message", T: AttachedText, opt: true },
    { no: 5, name: "source", kind: "message", T: ResourceReferenceChoice, opt: true },
    { no: 6, name: "target", kind: "message", T: ResourceReferenceChoice, opt: true },
    { no: 7, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Event {
    return new Event().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJsonString(jsonString, options);
  }

  static equals(a: Event | PlainMessage<Event> | undefined, b: Event | PlainMessage<Event> | undefined): boolean {
    return proto3.util.equals(Event, a, b);
  }
}

/**
 * Type that represents various input data types and formats.
 *
 * @generated from message cyclonedx.v1_6.InputType
 */
export class InputType extends Message<InputType> {
  /**
   * A references to the component or service that provided the input to the task (e.g., reference to a service with a data flow value of `inbound`)
   *
   * @generated from field: optional cyclonedx.v1_6.ResourceReferenceChoice source = 1;
   */
  source?: ResourceReferenceChoice;

  /**
   * A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)
   *
   * @generated from field: optional cyclonedx.v1_6.ResourceReferenceChoice target = 2;
   */
  target?: ResourceReferenceChoice;

  /**
   * A reference to an independent resource provided as an input to a task by the workflow runtime.
   *
   * @generated from field: optional cyclonedx.v1_6.ResourceReferenceChoice resource = 3;
   */
  resource?: ResourceReferenceChoice;

  /**
   * Inputs that have the form of parameters with names and values.
   *
   * @generated from field: repeated cyclonedx.v1_6.Parameter parameters = 4;
   */
  parameters: Parameter[] = [];

  /**
   * Inputs that have the form of parameters with names and values.
   *
   * @generated from field: repeated cyclonedx.v1_6.EnvironmentVars environmentVars = 5;
   */
  environmentVars: EnvironmentVars[] = [];

  /**
   * Inputs that have the form of data.
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText data = 6;
   */
  data?: AttachedText;

  /**
   * Additional properties of the input data.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 7;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<InputType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.InputType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: ResourceReferenceChoice, opt: true },
    { no: 2, name: "target", kind: "message", T: ResourceReferenceChoice, opt: true },
    { no: 3, name: "resource", kind: "message", T: ResourceReferenceChoice, opt: true },
    { no: 4, name: "parameters", kind: "message", T: Parameter, repeated: true },
    { no: 5, name: "environmentVars", kind: "message", T: EnvironmentVars, repeated: true },
    { no: 6, name: "data", kind: "message", T: AttachedText, opt: true },
    { no: 7, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InputType {
    return new InputType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InputType {
    return new InputType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InputType {
    return new InputType().fromJsonString(jsonString, options);
  }

  static equals(a: InputType | PlainMessage<InputType> | undefined, b: InputType | PlainMessage<InputType> | undefined): boolean {
    return proto3.util.equals(InputType, a, b);
  }
}

/**
 * Type that represents various output data types and formats.
 *
 * @generated from message cyclonedx.v1_6.OutputType
 */
export class OutputType extends Message<OutputType> {
  /**
   * Describes the type of data output.
   *
   * @generated from field: optional cyclonedx.v1_6.OutputType.OutputTypeType type = 1;
   */
  type?: OutputType_OutputTypeType;

  /**
   * Component or service that generated or provided the output from the task (e.g., a build tool)
   *
   * @generated from field: optional cyclonedx.v1_6.ResourceReferenceChoice source = 2;
   */
  source?: ResourceReferenceChoice;

  /**
   * Component or service that received the output from the task (e.g., reference to an artifactory service with data flow value of `outbound`)
   *
   * @generated from field: optional cyclonedx.v1_6.ResourceReferenceChoice target = 3;
   */
  target?: ResourceReferenceChoice;

  /**
   * A reference to an independent resource generated as output by the task.
   *
   * @generated from field: optional cyclonedx.v1_6.ResourceReferenceChoice resource = 4;
   */
  resource?: ResourceReferenceChoice;

  /**
   * Outputs that have the form of data.
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText data = 5;
   */
  data?: AttachedText;

  /**
   * Outputs that have the form of environment variables.
   *
   * @generated from field: repeated cyclonedx.v1_6.EnvironmentVars environmentVars = 6;
   */
  environmentVars: EnvironmentVars[] = [];

  /**
   * Additional properties of the output data.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 7;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<OutputType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.OutputType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(OutputType_OutputTypeType), opt: true },
    { no: 2, name: "source", kind: "message", T: ResourceReferenceChoice, opt: true },
    { no: 3, name: "target", kind: "message", T: ResourceReferenceChoice, opt: true },
    { no: 4, name: "resource", kind: "message", T: ResourceReferenceChoice, opt: true },
    { no: 5, name: "data", kind: "message", T: AttachedText, opt: true },
    { no: 6, name: "environmentVars", kind: "message", T: EnvironmentVars, repeated: true },
    { no: 7, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputType {
    return new OutputType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputType {
    return new OutputType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputType {
    return new OutputType().fromJsonString(jsonString, options);
  }

  static equals(a: OutputType | PlainMessage<OutputType> | undefined, b: OutputType | PlainMessage<OutputType> | undefined): boolean {
    return proto3.util.equals(OutputType, a, b);
  }
}

/**
 * buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "OUTPUT_TYPE_TYPE_"
 *
 * @generated from enum cyclonedx.v1_6.OutputType.OutputTypeType
 */
export enum OutputType_OutputTypeType {
  /**
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
   *
   * @generated from enum value: OUTPUT_TYPE_ARTIFACT = 0;
   */
  OUTPUT_TYPE_ARTIFACT = 0,

  /**
   * @generated from enum value: OUTPUT_TYPE_ATTESTATION = 1;
   */
  OUTPUT_TYPE_ATTESTATION = 1,

  /**
   * @generated from enum value: OUTPUT_TYPE_LOG = 2;
   */
  OUTPUT_TYPE_LOG = 2,

  /**
   * @generated from enum value: OUTPUT_TYPE_EVIDENCE = 3;
   */
  OUTPUT_TYPE_EVIDENCE = 3,

  /**
   * @generated from enum value: OUTPUT_TYPE_METRICS = 4;
   */
  OUTPUT_TYPE_METRICS = 4,

  /**
   * @generated from enum value: OUTPUT_TYPE_OTHER = 5;
   */
  OUTPUT_TYPE_OTHER = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(OutputType_OutputTypeType)
proto3.util.setEnumType(OutputType_OutputTypeType, "cyclonedx.v1_6.OutputType.OutputTypeType", [
  { no: 0, name: "OUTPUT_TYPE_ARTIFACT" },
  { no: 1, name: "OUTPUT_TYPE_ATTESTATION" },
  { no: 2, name: "OUTPUT_TYPE_LOG" },
  { no: 3, name: "OUTPUT_TYPE_EVIDENCE" },
  { no: 4, name: "OUTPUT_TYPE_METRICS" },
  { no: 5, name: "OUTPUT_TYPE_OTHER" },
]);

/**
 * Type that permits a choice to reference a resource using an iternal bom-ref identifier or an external reference.
 *
 * @generated from message cyclonedx.v1_6.ResourceReferenceChoice
 */
export class ResourceReferenceChoice extends Message<ResourceReferenceChoice> {
  /**
   * @generated from oneof cyclonedx.v1_6.ResourceReferenceChoice.choice
   */
  choice: {
    /**
     * @generated from field: string ref = 1;
     */
    value: string;
    case: "ref";
  } | {
    /**
     * @generated from field: cyclonedx.v1_6.ExternalReference externalReference = 2;
     */
    value: ExternalReference;
    case: "externalReference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ResourceReferenceChoice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.ResourceReferenceChoice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ref", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "choice" },
    { no: 2, name: "externalReference", kind: "message", T: ExternalReference, oneof: "choice" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceReferenceChoice {
    return new ResourceReferenceChoice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceReferenceChoice {
    return new ResourceReferenceChoice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceReferenceChoice {
    return new ResourceReferenceChoice().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceReferenceChoice | PlainMessage<ResourceReferenceChoice> | undefined, b: ResourceReferenceChoice | PlainMessage<ResourceReferenceChoice> | undefined): boolean {
    return proto3.util.equals(ResourceReferenceChoice, a, b);
  }
}

/**
 * A condition that was used to determine a trigger should be activated.
 *
 * @generated from message cyclonedx.v1_6.Condition
 */
export class Condition extends Message<Condition> {
  /**
   * Describes the set of conditions which cause the trigger to activate.
   *
   * @generated from field: optional string description = 1;
   */
  description?: string;

  /**
   * The logical expression that was evaluated that determined the trigger should be fired.
   *
   * @generated from field: optional string expression = 2;
   */
  expression?: string;

  /**
   * Domain-specific condition instance properties.
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 3;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<Condition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Condition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Condition {
    return new Condition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJsonString(jsonString, options);
  }

  static equals(a: Condition | PlainMessage<Condition> | undefined, b: Condition | PlainMessage<Condition> | undefined): boolean {
    return proto3.util.equals(Condition, a, b);
  }
}

/**
 * A representation of a functional parameter.
 *
 * @generated from message cyclonedx.v1_6.Parameter
 */
export class Parameter extends Message<Parameter> {
  /**
   * The name of the parameter.
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * The value of the parameter.
   *
   * @generated from field: optional string value = 2;
   */
  value?: string;

  /**
   * The data type of the parameter.
   *
   * @generated from field: optional string dataType = 3;
   */
  dataType?: string;

  constructor(data?: PartialMessage<Parameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Parameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "dataType", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Parameter {
    return new Parameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Parameter {
    return new Parameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Parameter {
    return new Parameter().fromJsonString(jsonString, options);
  }

  static equals(a: Parameter | PlainMessage<Parameter> | undefined, b: Parameter | PlainMessage<Parameter> | undefined): boolean {
    return proto3.util.equals(Parameter, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.EnvironmentVars
 */
export class EnvironmentVars extends Message<EnvironmentVars> {
  /**
   * @generated from oneof cyclonedx.v1_6.EnvironmentVars.choice
   */
  choice: {
    /**
     * @generated from field: cyclonedx.v1_6.Property property = 1;
     */
    value: Property;
    case: "property";
  } | {
    /**
     * @generated from field: string value = 2;
     */
    value: string;
    case: "value";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EnvironmentVars>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.EnvironmentVars";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property", kind: "message", T: Property, oneof: "choice" },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "choice" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnvironmentVars {
    return new EnvironmentVars().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnvironmentVars {
    return new EnvironmentVars().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnvironmentVars {
    return new EnvironmentVars().fromJsonString(jsonString, options);
  }

  static equals(a: EnvironmentVars | PlainMessage<EnvironmentVars> | undefined, b: EnvironmentVars | PlainMessage<EnvironmentVars> | undefined): boolean {
    return proto3.util.equals(EnvironmentVars, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations
 */
export class Declarations extends Message<Declarations> {
  /**
   * The list of assessors evaluating claims and determining conformance to requirements and confidence in that assessment.
   *
   * @generated from field: repeated cyclonedx.v1_6.Declarations.Assessor assessors = 1;
   */
  assessors: Declarations_Assessor[] = [];

  /**
   * The list of attestations asserted by an assessor that maps requirements to claims.
   *
   * @generated from field: repeated cyclonedx.v1_6.Declarations.Attestation attestations = 2;
   */
  attestations: Declarations_Attestation[] = [];

  /**
   * The list of claims.
   *
   * @generated from field: repeated cyclonedx.v1_6.Declarations.Claim claims = 3;
   */
  claims: Declarations_Claim[] = [];

  /**
   * The list of evidence
   *
   * @generated from field: repeated cyclonedx.v1_6.Declarations.Evidence evidence = 4;
   */
  evidence: Declarations_Evidence[] = [];

  /**
   * The list of targets which claims are made against.
   *
   * @generated from field: optional cyclonedx.v1_6.Declarations.Targets targets = 5;
   */
  targets?: Declarations_Targets;

  /**
   * affirmation
   *
   * @generated from field: optional cyclonedx.v1_6.Declarations.Affirmation affirmation = 6;
   */
  affirmation?: Declarations_Affirmation;

  constructor(data?: PartialMessage<Declarations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assessors", kind: "message", T: Declarations_Assessor, repeated: true },
    { no: 2, name: "attestations", kind: "message", T: Declarations_Attestation, repeated: true },
    { no: 3, name: "claims", kind: "message", T: Declarations_Claim, repeated: true },
    { no: 4, name: "evidence", kind: "message", T: Declarations_Evidence, repeated: true },
    { no: 5, name: "targets", kind: "message", T: Declarations_Targets, opt: true },
    { no: 6, name: "affirmation", kind: "message", T: Declarations_Affirmation, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations {
    return new Declarations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations {
    return new Declarations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations {
    return new Declarations().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations | PlainMessage<Declarations> | undefined, b: Declarations | PlainMessage<Declarations> | undefined): boolean {
    return proto3.util.equals(Declarations, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Assessor
 */
export class Declarations_Assessor extends Message<Declarations_Assessor> {
  /**
   * An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The boolean indicating if the assessor is outside the organization generating claims. A value of false indicates a self assessor.
   *
   * @generated from field: optional bool thirdParty = 2;
   */
  thirdParty?: boolean;

  /**
   * The entity issuing the assessment.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntity organization = 3;
   */
  organization?: OrganizationalEntity;

  constructor(data?: PartialMessage<Declarations_Assessor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Assessor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "thirdParty", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "organization", kind: "message", T: OrganizationalEntity, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Assessor {
    return new Declarations_Assessor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Assessor {
    return new Declarations_Assessor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Assessor {
    return new Declarations_Assessor().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Assessor | PlainMessage<Declarations_Assessor> | undefined, b: Declarations_Assessor | PlainMessage<Declarations_Assessor> | undefined): boolean {
    return proto3.util.equals(Declarations_Assessor, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Attestation
 */
export class Declarations_Attestation extends Message<Declarations_Attestation> {
  /**
   * The short description explaining the main points of the attestation.
   *
   * @generated from field: optional string summary = 1;
   */
  summary?: string;

  /**
   * The `bom-ref` to the assessor asserting the attestation.
   *
   * @generated from field: optional string assessor = 2;
   */
  assessor?: string;

  /**
   * The grouping of requirements to claims and the attestors' declared conformance and confidence thereof.
   *
   * @generated from field: repeated cyclonedx.v1_6.Declarations.Attestation.AttestationMap map = 3;
   */
  map: Declarations_Attestation_AttestationMap[] = [];

  constructor(data?: PartialMessage<Declarations_Attestation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Attestation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "summary", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "assessor", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "map", kind: "message", T: Declarations_Attestation_AttestationMap, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Attestation {
    return new Declarations_Attestation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Attestation {
    return new Declarations_Attestation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Attestation {
    return new Declarations_Attestation().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Attestation | PlainMessage<Declarations_Attestation> | undefined, b: Declarations_Attestation | PlainMessage<Declarations_Attestation> | undefined): boolean {
    return proto3.util.equals(Declarations_Attestation, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Attestation.AttestationMap
 */
export class Declarations_Attestation_AttestationMap extends Message<Declarations_Attestation_AttestationMap> {
  /**
   * The `bom-ref` to the requirement being attested to.
   *
   * @generated from field: optional string requirement = 1;
   */
  requirement?: string;

  /**
   * The list of `bom-ref` to the claims being attested to.
   *
   * @generated from field: repeated string claims = 2;
   */
  claims: string[] = [];

  /**
   * The list of  `bom-ref` to the counter claims being attested to.
   *
   * @generated from field: repeated string counterClaims = 3;
   */
  counterClaims: string[] = [];

  /**
   * The conformance of the claim meeting a requirement.
   *
   * @generated from field: optional cyclonedx.v1_6.Declarations.Attestation.AttestationMap.AttestationConformance conformance = 4;
   */
  conformance?: Declarations_Attestation_AttestationMap_AttestationConformance;

  /**
   * The confidence of the claim meeting the requirement.
   *
   * @generated from field: optional cyclonedx.v1_6.Declarations.Attestation.AttestationMap.AttestationConfidence confidence = 5;
   */
  confidence?: Declarations_Attestation_AttestationMap_AttestationConfidence;

  constructor(data?: PartialMessage<Declarations_Attestation_AttestationMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Attestation.AttestationMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requirement", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "claims", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "counterClaims", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "conformance", kind: "message", T: Declarations_Attestation_AttestationMap_AttestationConformance, opt: true },
    { no: 5, name: "confidence", kind: "message", T: Declarations_Attestation_AttestationMap_AttestationConfidence, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Attestation_AttestationMap {
    return new Declarations_Attestation_AttestationMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Attestation_AttestationMap {
    return new Declarations_Attestation_AttestationMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Attestation_AttestationMap {
    return new Declarations_Attestation_AttestationMap().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Attestation_AttestationMap | PlainMessage<Declarations_Attestation_AttestationMap> | undefined, b: Declarations_Attestation_AttestationMap | PlainMessage<Declarations_Attestation_AttestationMap> | undefined): boolean {
    return proto3.util.equals(Declarations_Attestation_AttestationMap, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Attestation.AttestationMap.AttestationConformance
 */
export class Declarations_Attestation_AttestationMap_AttestationConformance extends Message<Declarations_Attestation_AttestationMap_AttestationConformance> {
  /**
   * The conformance of the claim between and inclusive of 0 and 1, where 1 is 100% conformance.
   *
   * @generated from field: optional double score = 1;
   */
  score?: number;

  /**
   * The rationale for the conformance score.
   *
   * @generated from field: optional string rationale = 2;
   */
  rationale?: string;

  /**
   * The list of  `bom-ref` to the evidence provided describing the mitigation strategies.
   *
   * @generated from field: repeated string mitigationStrategies = 3;
   */
  mitigationStrategies: string[] = [];

  constructor(data?: PartialMessage<Declarations_Attestation_AttestationMap_AttestationConformance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Attestation.AttestationMap.AttestationConformance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "score", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "rationale", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "mitigationStrategies", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Attestation_AttestationMap_AttestationConformance {
    return new Declarations_Attestation_AttestationMap_AttestationConformance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Attestation_AttestationMap_AttestationConformance {
    return new Declarations_Attestation_AttestationMap_AttestationConformance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Attestation_AttestationMap_AttestationConformance {
    return new Declarations_Attestation_AttestationMap_AttestationConformance().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Attestation_AttestationMap_AttestationConformance | PlainMessage<Declarations_Attestation_AttestationMap_AttestationConformance> | undefined, b: Declarations_Attestation_AttestationMap_AttestationConformance | PlainMessage<Declarations_Attestation_AttestationMap_AttestationConformance> | undefined): boolean {
    return proto3.util.equals(Declarations_Attestation_AttestationMap_AttestationConformance, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Attestation.AttestationMap.AttestationConfidence
 */
export class Declarations_Attestation_AttestationMap_AttestationConfidence extends Message<Declarations_Attestation_AttestationMap_AttestationConfidence> {
  /**
   * The confidence of the claim between and inclusive of 0 and 1, where 1 is 100% confidence.
   *
   * @generated from field: optional double score = 1;
   */
  score?: number;

  /**
   * The rationale for the confidence score.
   *
   * @generated from field: optional string rationale = 2;
   */
  rationale?: string;

  constructor(data?: PartialMessage<Declarations_Attestation_AttestationMap_AttestationConfidence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Attestation.AttestationMap.AttestationConfidence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "score", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "rationale", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Attestation_AttestationMap_AttestationConfidence {
    return new Declarations_Attestation_AttestationMap_AttestationConfidence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Attestation_AttestationMap_AttestationConfidence {
    return new Declarations_Attestation_AttestationMap_AttestationConfidence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Attestation_AttestationMap_AttestationConfidence {
    return new Declarations_Attestation_AttestationMap_AttestationConfidence().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Attestation_AttestationMap_AttestationConfidence | PlainMessage<Declarations_Attestation_AttestationMap_AttestationConfidence> | undefined, b: Declarations_Attestation_AttestationMap_AttestationConfidence | PlainMessage<Declarations_Attestation_AttestationMap_AttestationConfidence> | undefined): boolean {
    return proto3.util.equals(Declarations_Attestation_AttestationMap_AttestationConfidence, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Claim
 */
export class Declarations_Claim extends Message<Declarations_Claim> {
  /**
   * An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The `bom-ref` to a target representing a specific system, application, API, module, team, person, process, business unit, company, etc...  that this claim is being applied to.
   *
   * @generated from field: optional string target = 2;
   */
  target?: string;

  /**
   * The specific statement or assertion about the target.
   *
   * @generated from field: optional string predicate = 3;
   */
  predicate?: string;

  /**
   * The list of  `bom-ref` to the evidence provided describing the mitigation strategies. Each mitigation strategy should include an explanation of how any weaknesses in the evidence will be mitigated.
   *
   * @generated from field: repeated string mitigationStrategies = 4;
   */
  mitigationStrategies: string[] = [];

  /**
   * The written explanation of why the evidence provided substantiates the claim.
   *
   * @generated from field: optional string reasoning = 5;
   */
  reasoning?: string;

  /**
   * The list of `bom-ref` to evidence that supports this claim.
   *
   * @generated from field: repeated string evidence = 6;
   */
  evidence: string[] = [];

  /**
   * The list of `bom-ref` to counterEvidence that supports this claim.
   *
   * @generated from field: repeated string counterEvidence = 7;
   */
  counterEvidence: string[] = [];

  /**
   * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
   *
   * @generated from field: repeated cyclonedx.v1_6.ExternalReference externalReferences = 8;
   */
  externalReferences: ExternalReference[] = [];

  constructor(data?: PartialMessage<Declarations_Claim>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Claim";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "predicate", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "mitigationStrategies", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "reasoning", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "evidence", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "counterEvidence", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "externalReferences", kind: "message", T: ExternalReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Claim {
    return new Declarations_Claim().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Claim {
    return new Declarations_Claim().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Claim {
    return new Declarations_Claim().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Claim | PlainMessage<Declarations_Claim> | undefined, b: Declarations_Claim | PlainMessage<Declarations_Claim> | undefined): boolean {
    return proto3.util.equals(Declarations_Claim, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Evidence
 */
export class Declarations_Evidence extends Message<Declarations_Evidence> {
  /**
   * An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The reference to the property name as defined in the CycloneDX Property Taxonomy: https://github.com/CycloneDX/cyclonedx-property-taxonomy/.
   *
   * @generated from field: optional string propertyName = 2;
   */
  propertyName?: string;

  /**
   * The written description of what this evidence is and how it was created.
   *
   * @generated from field: optional string description = 3;
   */
  description?: string;

  /**
   * The output or analysis that supports claims.
   *
   * @generated from field: repeated cyclonedx.v1_6.Declarations.Evidence.Data data = 4;
   */
  data: Declarations_Evidence_Data[] = [];

  /**
   * The date and time (timestamp) when the evidence was created.
   *
   * @generated from field: optional google.protobuf.Timestamp created = 5;
   */
  created?: Timestamp;

  /**
   * The optional date and time (timestamp) when the evidence is no longer valid.
   *
   * @generated from field: optional google.protobuf.Timestamp expires = 6;
   */
  expires?: Timestamp;

  /**
   * The author of the evidence.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalContact author = 7;
   */
  author?: OrganizationalContact;

  /**
   * The reviewer of the evidence.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalContact reviewer = 8;
   */
  reviewer?: OrganizationalContact;

  constructor(data?: PartialMessage<Declarations_Evidence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Evidence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "propertyName", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "data", kind: "message", T: Declarations_Evidence_Data, repeated: true },
    { no: 5, name: "created", kind: "message", T: Timestamp, opt: true },
    { no: 6, name: "expires", kind: "message", T: Timestamp, opt: true },
    { no: 7, name: "author", kind: "message", T: OrganizationalContact, opt: true },
    { no: 8, name: "reviewer", kind: "message", T: OrganizationalContact, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Evidence {
    return new Declarations_Evidence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Evidence {
    return new Declarations_Evidence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Evidence {
    return new Declarations_Evidence().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Evidence | PlainMessage<Declarations_Evidence> | undefined, b: Declarations_Evidence | PlainMessage<Declarations_Evidence> | undefined): boolean {
    return proto3.util.equals(Declarations_Evidence, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Evidence.Data
 */
export class Declarations_Evidence_Data extends Message<Declarations_Evidence_Data> {
  /**
   * The name of the data.
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * The contents or references to the contents of the data being described.
   *
   * @generated from field: optional cyclonedx.v1_6.Declarations.Evidence.Data.Contents contents = 2;
   */
  contents?: Declarations_Evidence_Data_Contents;

  /**
   * Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed.
   *
   * @generated from field: optional string classification = 3;
   */
  classification?: string;

  /**
   * A description of any sensitive data included.
   *
   * @generated from field: repeated string sensitiveData = 4;
   */
  sensitiveData: string[] = [];

  /**
   * Data Governance
   *
   * @generated from field: optional cyclonedx.v1_6.DataGovernance governance = 5;
   */
  governance?: DataGovernance;

  constructor(data?: PartialMessage<Declarations_Evidence_Data>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Evidence.Data";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "contents", kind: "message", T: Declarations_Evidence_Data_Contents, opt: true },
    { no: 3, name: "classification", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "sensitiveData", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "governance", kind: "message", T: DataGovernance, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Evidence_Data {
    return new Declarations_Evidence_Data().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Evidence_Data {
    return new Declarations_Evidence_Data().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Evidence_Data {
    return new Declarations_Evidence_Data().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Evidence_Data | PlainMessage<Declarations_Evidence_Data> | undefined, b: Declarations_Evidence_Data | PlainMessage<Declarations_Evidence_Data> | undefined): boolean {
    return proto3.util.equals(Declarations_Evidence_Data, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Evidence.Data.Contents
 */
export class Declarations_Evidence_Data_Contents extends Message<Declarations_Evidence_Data_Contents> {
  /**
   * An optional way to include textual or encoded data.
   *
   * @generated from field: optional cyclonedx.v1_6.AttachedText attachment = 1;
   */
  attachment?: AttachedText;

  /**
   * The URL to where the data can be retrieved.
   *
   * @generated from field: optional string url = 2;
   */
  url?: string;

  constructor(data?: PartialMessage<Declarations_Evidence_Data_Contents>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Evidence.Data.Contents";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attachment", kind: "message", T: AttachedText, opt: true },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Evidence_Data_Contents {
    return new Declarations_Evidence_Data_Contents().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Evidence_Data_Contents {
    return new Declarations_Evidence_Data_Contents().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Evidence_Data_Contents {
    return new Declarations_Evidence_Data_Contents().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Evidence_Data_Contents | PlainMessage<Declarations_Evidence_Data_Contents> | undefined, b: Declarations_Evidence_Data_Contents | PlainMessage<Declarations_Evidence_Data_Contents> | undefined): boolean {
    return proto3.util.equals(Declarations_Evidence_Data_Contents, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Targets
 */
export class Declarations_Targets extends Message<Declarations_Targets> {
  /**
   * The list of organizations which claims are made against.
   *
   * @generated from field: repeated cyclonedx.v1_6.OrganizationalEntity organizations = 1;
   */
  organizations: OrganizationalEntity[] = [];

  /**
   * The list of components which claims are made against.
   *
   * @generated from field: repeated cyclonedx.v1_6.Component components = 2;
   */
  components: Component[] = [];

  /**
   * The list of services which claims are made against.
   *
   * @generated from field: repeated cyclonedx.v1_6.Service services = 3;
   */
  services: Service[] = [];

  constructor(data?: PartialMessage<Declarations_Targets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Targets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "organizations", kind: "message", T: OrganizationalEntity, repeated: true },
    { no: 2, name: "components", kind: "message", T: Component, repeated: true },
    { no: 3, name: "services", kind: "message", T: Service, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Targets {
    return new Declarations_Targets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Targets {
    return new Declarations_Targets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Targets {
    return new Declarations_Targets().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Targets | PlainMessage<Declarations_Targets> | undefined, b: Declarations_Targets | PlainMessage<Declarations_Targets> | undefined): boolean {
    return proto3.util.equals(Declarations_Targets, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Affirmation
 */
export class Declarations_Affirmation extends Message<Declarations_Affirmation> {
  /**
   * The brief statement affirmed by an individual regarding all declarations. Notes: This could be an affirmation of acceptance by a third-party auditor or receiving individual of a file.
   *
   * @generated from field: optional string statement = 1;
   */
  statement?: string;

  /**
   * The list of signatories authorized on behalf of an organization to assert validity of this document.
   *
   * @generated from field: repeated cyclonedx.v1_6.Declarations.Affirmation.Signatory signatories = 2;
   */
  signatories: Declarations_Affirmation_Signatory[] = [];

  constructor(data?: PartialMessage<Declarations_Affirmation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Affirmation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statement", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "signatories", kind: "message", T: Declarations_Affirmation_Signatory, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Affirmation {
    return new Declarations_Affirmation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Affirmation {
    return new Declarations_Affirmation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Affirmation {
    return new Declarations_Affirmation().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Affirmation | PlainMessage<Declarations_Affirmation> | undefined, b: Declarations_Affirmation | PlainMessage<Declarations_Affirmation> | undefined): boolean {
    return proto3.util.equals(Declarations_Affirmation, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Declarations.Affirmation.Signatory
 */
export class Declarations_Affirmation_Signatory extends Message<Declarations_Affirmation_Signatory> {
  /**
   * The signatory's name.
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * The signatory's role within an organization.
   *
   * @generated from field: optional string role = 2;
   */
  role?: string;

  /**
   * The signatory's organization.
   *
   * @generated from field: optional cyclonedx.v1_6.OrganizationalEntity organization = 3;
   */
  organization?: OrganizationalEntity;

  /**
   * An External reference provides a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
   *
   * @generated from field: optional cyclonedx.v1_6.ExternalReference externalReference = 4;
   */
  externalReference?: ExternalReference;

  constructor(data?: PartialMessage<Declarations_Affirmation_Signatory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Declarations.Affirmation.Signatory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "organization", kind: "message", T: OrganizationalEntity, opt: true },
    { no: 4, name: "externalReference", kind: "message", T: ExternalReference, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Declarations_Affirmation_Signatory {
    return new Declarations_Affirmation_Signatory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Declarations_Affirmation_Signatory {
    return new Declarations_Affirmation_Signatory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Declarations_Affirmation_Signatory {
    return new Declarations_Affirmation_Signatory().fromJsonString(jsonString, options);
  }

  static equals(a: Declarations_Affirmation_Signatory | PlainMessage<Declarations_Affirmation_Signatory> | undefined, b: Declarations_Affirmation_Signatory | PlainMessage<Declarations_Affirmation_Signatory> | undefined): boolean {
    return proto3.util.equals(Declarations_Affirmation_Signatory, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Definition
 */
export class Definition extends Message<Definition> {
  /**
   * @generated from field: repeated cyclonedx.v1_6.Definition.Standard standards = 1;
   */
  standards: Definition_Standard[] = [];

  constructor(data?: PartialMessage<Definition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Definition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "standards", kind: "message", T: Definition_Standard, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Definition {
    return new Definition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Definition {
    return new Definition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Definition {
    return new Definition().fromJsonString(jsonString, options);
  }

  static equals(a: Definition | PlainMessage<Definition> | undefined, b: Definition | PlainMessage<Definition> | undefined): boolean {
    return proto3.util.equals(Definition, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Definition.Standard
 */
export class Definition_Standard extends Message<Definition_Standard> {
  /**
   * An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The name of the standard. This will often be a shortened, single name of the standard.
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * The version of the standard.
   *
   * @generated from field: optional string version = 3;
   */
  version?: string;

  /**
   * The description of the standard.
   *
   * @generated from field: optional string description = 4;
   */
  description?: string;

  /**
   * The owner of the standard, often the entity responsible for its release.
   *
   * @generated from field: optional string owner = 5;
   */
  owner?: string;

  /**
   * The list of requirements comprising the standard.
   *
   * @generated from field: repeated cyclonedx.v1_6.Definition.Standard.Requirement requirements = 6;
   */
  requirements: Definition_Standard_Requirement[] = [];

  /**
   * The list of levels associated with the standard. Some standards have different levels of compliance.
   *
   * @generated from field: repeated cyclonedx.v1_6.Definition.Standard.Level levels = 7;
   */
  levels: Definition_Standard_Level[] = [];

  /**
   * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
   *
   * @generated from field: repeated cyclonedx.v1_6.ExternalReference externalReferences = 8;
   */
  externalReferences: ExternalReference[] = [];

  constructor(data?: PartialMessage<Definition_Standard>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Definition.Standard";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "owner", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "requirements", kind: "message", T: Definition_Standard_Requirement, repeated: true },
    { no: 7, name: "levels", kind: "message", T: Definition_Standard_Level, repeated: true },
    { no: 8, name: "externalReferences", kind: "message", T: ExternalReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Definition_Standard {
    return new Definition_Standard().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Definition_Standard {
    return new Definition_Standard().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Definition_Standard {
    return new Definition_Standard().fromJsonString(jsonString, options);
  }

  static equals(a: Definition_Standard | PlainMessage<Definition_Standard> | undefined, b: Definition_Standard | PlainMessage<Definition_Standard> | undefined): boolean {
    return proto3.util.equals(Definition_Standard, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Definition.Standard.Requirement
 */
export class Definition_Standard_Requirement extends Message<Definition_Standard_Requirement> {
  /**
   * An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The unique identifier used in the standard to identify a specific requirement. This should match what is in the standard and should not be the requirements bom-ref.
   *
   * @generated from field: optional string identifier = 2;
   */
  identifier?: string;

  /**
   * The title of the requirement.
   *
   * @generated from field: optional string title = 3;
   */
  title?: string;

  /**
   * The textual content of the requirement.
   *
   * @generated from field: optional string text = 4;
   */
  text?: string;

  /**
   * The supplemental text that provides additional guidance or context to the requirement but is not directly part of the requirement.
   *
   * @generated from field: repeated string descriptions = 5;
   */
  descriptions: string[] = [];

  /**
   * The Common Requirements Enumeration (CRE) identifier(s). CRE is a structured and standardized framework for uniting security standards and guidelines. CRE links each section of a resource to a shared topic identifier (a Common Requirement). Through this shared topic link, all resources map to each other. The use of CRE promotes clear and unambiguous communication among stakeholders.
   *
   * @generated from field: repeated string openCre = 6;
   */
  openCre: string[] = [];

  /**
   * The optional `bom-ref` to a parent requirement. This establishes a hierarchy of requirements. Top-level requirements must not define a parent. Only child requirements should define parents.
   *
   * @generated from field: optional string parent = 7;
   */
  parent?: string;

  /**
   * Specifies optional, custom, properties
   *
   * @generated from field: repeated cyclonedx.v1_6.Property properties = 8;
   */
  properties: Property[] = [];

  /**
   * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
   *
   * @generated from field: repeated cyclonedx.v1_6.ExternalReference externalReferences = 9;
   */
  externalReferences: ExternalReference[] = [];

  constructor(data?: PartialMessage<Definition_Standard_Requirement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Definition.Standard.Requirement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "identifier", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "descriptions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "openCre", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "properties", kind: "message", T: Property, repeated: true },
    { no: 9, name: "externalReferences", kind: "message", T: ExternalReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Definition_Standard_Requirement {
    return new Definition_Standard_Requirement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Definition_Standard_Requirement {
    return new Definition_Standard_Requirement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Definition_Standard_Requirement {
    return new Definition_Standard_Requirement().fromJsonString(jsonString, options);
  }

  static equals(a: Definition_Standard_Requirement | PlainMessage<Definition_Standard_Requirement> | undefined, b: Definition_Standard_Requirement | PlainMessage<Definition_Standard_Requirement> | undefined): boolean {
    return proto3.util.equals(Definition_Standard_Requirement, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.Definition.Standard.Level
 */
export class Definition_Standard_Level extends Message<Definition_Standard_Level> {
  /**
   * An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
   *
   * @generated from field: optional string bom_ref = 1;
   */
  bomRef?: string;

  /**
   * The identifier used in the standard to identify a specific level.
   *
   * @generated from field: optional string identifier = 2;
   */
  identifier?: string;

  /**
   * The title of the level.
   *
   * @generated from field: optional string title = 3;
   */
  title?: string;

  /**
   * The description of the level.
   *
   * @generated from field: optional string description = 4;
   */
  description?: string;

  /**
   * The list of requirement `bom-ref`s that comprise the level.
   *
   * @generated from field: repeated string requirements = 5;
   */
  requirements: string[] = [];

  constructor(data?: PartialMessage<Definition_Standard_Level>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.Definition.Standard.Level";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bom_ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "identifier", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "requirements", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Definition_Standard_Level {
    return new Definition_Standard_Level().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Definition_Standard_Level {
    return new Definition_Standard_Level().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Definition_Standard_Level {
    return new Definition_Standard_Level().fromJsonString(jsonString, options);
  }

  static equals(a: Definition_Standard_Level | PlainMessage<Definition_Standard_Level> | undefined, b: Definition_Standard_Level | PlainMessage<Definition_Standard_Level> | undefined): boolean {
    return proto3.util.equals(Definition_Standard_Level, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.CryptoProperties
 */
export class CryptoProperties extends Message<CryptoProperties> {
  /**
   * Cryptographic assets occur in several forms. Algorithms and protocols are most commonly implemented in specialized cryptographic libraries. They may, however, also be 'hardcoded' in software components. Certificates and related cryptographic material like keys, tokens, secrets or passwords are other cryptographic assets to be modelled.
   *
   * @generated from field: cyclonedx.v1_6.CryptoProperties.CryptoAssetType assetType = 1;
   */
  assetType = CryptoProperties_CryptoAssetType.UNSPECIFIED;

  /**
   * Additional properties specific to a cryptographic algorithm.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.AlgorithmProperties algorithmProperties = 2;
   */
  algorithmProperties?: CryptoProperties_AlgorithmProperties;

  /**
   * Properties for cryptographic assets of asset type 'certificate'
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.CertificateProperties certificateProperties = 3;
   */
  certificateProperties?: CryptoProperties_CertificateProperties;

  /**
   * Properties for cryptographic assets of asset type: `related-crypto-material`
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties relatedCryptoMaterialProperties = 4;
   */
  relatedCryptoMaterialProperties?: CryptoProperties_RelatedCryptoMaterialProperties;

  /**
   * Properties specific to cryptographic assets of type: `protocol`.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.ProtocolProperties protocolProperties = 5;
   */
  protocolProperties?: CryptoProperties_ProtocolProperties;

  /**
   * The object identifier (OID) of the cryptographic asset.
   *
   * @generated from field: optional string oid = 6;
   */
  oid?: string;

  constructor(data?: PartialMessage<CryptoProperties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.CryptoProperties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assetType", kind: "enum", T: proto3.getEnumType(CryptoProperties_CryptoAssetType) },
    { no: 2, name: "algorithmProperties", kind: "message", T: CryptoProperties_AlgorithmProperties, opt: true },
    { no: 3, name: "certificateProperties", kind: "message", T: CryptoProperties_CertificateProperties, opt: true },
    { no: 4, name: "relatedCryptoMaterialProperties", kind: "message", T: CryptoProperties_RelatedCryptoMaterialProperties, opt: true },
    { no: 5, name: "protocolProperties", kind: "message", T: CryptoProperties_ProtocolProperties, opt: true },
    { no: 6, name: "oid", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoProperties {
    return new CryptoProperties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoProperties {
    return new CryptoProperties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoProperties {
    return new CryptoProperties().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoProperties | PlainMessage<CryptoProperties> | undefined, b: CryptoProperties | PlainMessage<CryptoProperties> | undefined): boolean {
    return proto3.util.equals(CryptoProperties, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.CryptoAssetType
 */
export enum CryptoProperties_CryptoAssetType {
  /**
   * ProtoBuff's default value
   *
   * @generated from enum value: CRYPTO_ASSET_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CRYPTO_ASSET_TYPE_ALGORITHM = 1;
   */
  ALGORITHM = 1,

  /**
   * @generated from enum value: CRYPTO_ASSET_TYPE_CERTIFICATE = 2;
   */
  CERTIFICATE = 2,

  /**
   * @generated from enum value: CRYPTO_ASSET_TYPE_PROTOCOL = 3;
   */
  PROTOCOL = 3,

  /**
   * @generated from enum value: CRYPTO_ASSET_TYPE_RELATED_CRYPTO_MATERIAL = 4;
   */
  RELATED_CRYPTO_MATERIAL = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_CryptoAssetType)
proto3.util.setEnumType(CryptoProperties_CryptoAssetType, "cyclonedx.v1_6.CryptoProperties.CryptoAssetType", [
  { no: 0, name: "CRYPTO_ASSET_TYPE_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_ASSET_TYPE_ALGORITHM" },
  { no: 2, name: "CRYPTO_ASSET_TYPE_CERTIFICATE" },
  { no: 3, name: "CRYPTO_ASSET_TYPE_PROTOCOL" },
  { no: 4, name: "CRYPTO_ASSET_TYPE_RELATED_CRYPTO_MATERIAL" },
]);

/**
 * @generated from message cyclonedx.v1_6.CryptoProperties.AlgorithmProperties
 */
export class CryptoProperties_AlgorithmProperties extends Message<CryptoProperties_AlgorithmProperties> {
  /**
   * Cryptographic building blocks used in higher-level cryptographic systems and protocols. Primitives represent different cryptographic routines: deterministic random bit generators (drbg, e.g. CTR_DRBG from NIST SP800-90A-r1), message authentication codes (mac, e.g. HMAC-SHA-256), blockciphers (e.g. AES), streamciphers (e.g. Salsa20), signatures (e.g. ECDSA), hash functions (e.g. SHA-256), public-key encryption schemes (pke, e.g. RSA), extended output functions (xof, e.g. SHAKE256), key derivation functions (e.g. pbkdf2), key agreement algorithms (e.g. ECDH), key encapsulation mechanisms (e.g. ML-KEM), authenticated encryption (ae, e.g. AES-GCM) and the combination of multiple algorithms (combiner, e.g. SP800-56Cr2).
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoPrimitive primitive = 1;
   */
  primitive?: CryptoProperties_AlgorithmProperties_CryptoPrimitive;

  /**
   * An identifier for the parameter set of the cryptographic algorithm. Examples: in AES128, '128' identifies the key length in bits, in SHA256, '256' identifies the digest length, '128' in SHAKE128 identifies its maximum security level in bits, and 'SHA2-128s' identifies a parameter set used in SLH-DSA (FIPS205).
   *
   * @generated from field: optional string parameterSetIdentifier = 2;
   */
  parameterSetIdentifier?: string;

  /**
   * The specific underlying Elliptic Curve (EC) definition employed which is an indicator of the level of security strength, performance and complexity. Absent an authoritative source of curve names, CycloneDX recommends use of curve names as defined at [https://neuromancer.sk/std/](https://neuromancer.sk/std/), the source from which can be found at [https://github.com/J08nY/std-curves](https://github.com/J08nY/std-curves).
   *
   * @generated from field: optional string curve = 3;
   */
  curve?: string;

  /**
   * The target and execution environment in which the algorithm is implemented in.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoExecutionEnvironment executionEnvironment = 4;
   */
  executionEnvironment?: CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment;

  /**
   * The target platform for which the algorithm is implemented. The implementation can be 'generic', running on any platform or for a specific platform.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoImplementationPlatform implementationPlatform = 5;
   */
  implementationPlatform?: CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform;

  /**
   * The certification that the implementation of the cryptographic algorithm has received, if any. Certifications include revisions and levels of FIPS 140 or Common Criteria of different Extended Assurance Levels (CC-EAL).
   *
   * @generated from field: repeated string certificationLevel = 6;
   */
  certificationLevel: string[] = [];

  /**
   * The mode of operation in which the cryptographic algorithm (block cipher) is used.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoAlgorithmMode mode = 7;
   */
  mode?: CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode;

  /**
   * The padding scheme that is used for the cryptographic algorithm.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoAlgorithmPadding padding = 8;
   */
  padding?: CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding;

  /**
   * The cryptographic functions implemented by the cryptographic algorithm.
   *
   * @generated from field: repeated cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoAlgorithmFunction cryptoFunctions = 9;
   */
  cryptoFunctions: CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction[] = [];

  /**
   * The classical security level that a cryptographic algorithm provides (in bits).
   *
   * @generated from field: optional int32 classicalSecurityLevel = 10;
   */
  classicalSecurityLevel?: number;

  /**
   * The NIST security strength category as defined in https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria). A value of 0 indicates that none of the categories are met.
   *
   * @generated from field: optional int32 nistQuantumSecurityLevel = 11;
   */
  nistQuantumSecurityLevel?: number;

  constructor(data?: PartialMessage<CryptoProperties_AlgorithmProperties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.CryptoProperties.AlgorithmProperties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "primitive", kind: "enum", T: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoPrimitive), opt: true },
    { no: 2, name: "parameterSetIdentifier", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "curve", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "executionEnvironment", kind: "enum", T: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment), opt: true },
    { no: 5, name: "implementationPlatform", kind: "enum", T: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform), opt: true },
    { no: 6, name: "certificationLevel", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "mode", kind: "enum", T: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode), opt: true },
    { no: 8, name: "padding", kind: "enum", T: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding), opt: true },
    { no: 9, name: "cryptoFunctions", kind: "enum", T: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction), repeated: true },
    { no: 10, name: "classicalSecurityLevel", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 11, name: "nistQuantumSecurityLevel", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoProperties_AlgorithmProperties {
    return new CryptoProperties_AlgorithmProperties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoProperties_AlgorithmProperties {
    return new CryptoProperties_AlgorithmProperties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoProperties_AlgorithmProperties {
    return new CryptoProperties_AlgorithmProperties().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoProperties_AlgorithmProperties | PlainMessage<CryptoProperties_AlgorithmProperties> | undefined, b: CryptoProperties_AlgorithmProperties | PlainMessage<CryptoProperties_AlgorithmProperties> | undefined): boolean {
    return proto3.util.equals(CryptoProperties_AlgorithmProperties, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoPrimitive
 */
export enum CryptoProperties_AlgorithmProperties_CryptoPrimitive {
  /**
   * ProtoBuff's default value -- it differs from "unknown"
   *
   * @generated from enum value: CRYPTO_PRIMITIVE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The primitive is not known
   *
   * @generated from enum value: CRYPTO_PRIMITIVE_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * Another primitive type - none of the following
   *
   * @generated from enum value: CRYPTO_PRIMITIVE_OTHER = 2;
   */
  OTHER = 2,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_DRBG = 3;
   */
  DRBG = 3,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_MAC = 4;
   */
  MAC = 4,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_BLOCK_CIPHER = 5;
   */
  BLOCK_CIPHER = 5,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_STREAM_CIPHER = 6;
   */
  STREAM_CIPHER = 6,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_SIGNATURE = 7;
   */
  SIGNATURE = 7,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_HASH = 8;
   */
  HASH = 8,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_PKE = 9;
   */
  PKE = 9,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_XOF = 10;
   */
  XOF = 10,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_KDF = 11;
   */
  KDF = 11,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_KEY_AGREE = 12;
   */
  KEY_AGREE = 12,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_KEM = 13;
   */
  KEM = 13,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_AE = 14;
   */
  AE = 14,

  /**
   * @generated from enum value: CRYPTO_PRIMITIVE_COMBINER = 15;
   */
  COMBINER = 15,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoPrimitive)
proto3.util.setEnumType(CryptoProperties_AlgorithmProperties_CryptoPrimitive, "cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoPrimitive", [
  { no: 0, name: "CRYPTO_PRIMITIVE_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_PRIMITIVE_UNKNOWN" },
  { no: 2, name: "CRYPTO_PRIMITIVE_OTHER" },
  { no: 3, name: "CRYPTO_PRIMITIVE_DRBG" },
  { no: 4, name: "CRYPTO_PRIMITIVE_MAC" },
  { no: 5, name: "CRYPTO_PRIMITIVE_BLOCK_CIPHER" },
  { no: 6, name: "CRYPTO_PRIMITIVE_STREAM_CIPHER" },
  { no: 7, name: "CRYPTO_PRIMITIVE_SIGNATURE" },
  { no: 8, name: "CRYPTO_PRIMITIVE_HASH" },
  { no: 9, name: "CRYPTO_PRIMITIVE_PKE" },
  { no: 10, name: "CRYPTO_PRIMITIVE_XOF" },
  { no: 11, name: "CRYPTO_PRIMITIVE_KDF" },
  { no: 12, name: "CRYPTO_PRIMITIVE_KEY_AGREE" },
  { no: 13, name: "CRYPTO_PRIMITIVE_KEM" },
  { no: 14, name: "CRYPTO_PRIMITIVE_AE" },
  { no: 15, name: "CRYPTO_PRIMITIVE_COMBINER" },
]);

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoExecutionEnvironment
 */
export enum CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment {
  /**
   * ProtoBuff's default value -- it differs from "unknown"
   *
   * @generated from enum value: CRYPTO_EXECUTION_ENVIRONMENT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The execution environment is not known
   *
   * @generated from enum value: CRYPTO_EXECUTION_ENVIRONMENT_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * Another implementation environment - none of the following
   *
   * @generated from enum value: CRYPTO_EXECUTION_ENVIRONMENT_OTHER = 2;
   */
  OTHER = 2,

  /**
   * @generated from enum value: CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_PLAIN_RAM = 3;
   */
  SOFTWARE_PLAIN_RAM = 3,

  /**
   * @generated from enum value: CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_ENCRYPTED_RAM = 4;
   */
  SOFTWARE_ENCRYPTED_RAM = 4,

  /**
   * @generated from enum value: CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_TEE = 5;
   */
  SOFTWARE_TEE = 5,

  /**
   * @generated from enum value: CRYPTO_EXECUTION_ENVIRONMENT_HARDWARE = 6;
   */
  HARDWARE = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment)
proto3.util.setEnumType(CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment, "cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoExecutionEnvironment", [
  { no: 0, name: "CRYPTO_EXECUTION_ENVIRONMENT_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_EXECUTION_ENVIRONMENT_UNKNOWN" },
  { no: 2, name: "CRYPTO_EXECUTION_ENVIRONMENT_OTHER" },
  { no: 3, name: "CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_PLAIN_RAM" },
  { no: 4, name: "CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_ENCRYPTED_RAM" },
  { no: 5, name: "CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_TEE" },
  { no: 6, name: "CRYPTO_EXECUTION_ENVIRONMENT_HARDWARE" },
]);

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoImplementationPlatform
 */
export enum CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform {
  /**
   * ProtoBuff's default value -- it differs from "unknown"
   *
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * the platform is not known
   *
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * none of the following
   *
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_OTHER = 2;
   */
  OTHER = 2,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_GENERIC = 3;
   */
  GENERIC = 3,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_X86_32 = 4;
   */
  X86_32 = 4,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_X86_64 = 5;
   */
  X86_64 = 5,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7A = 6;
   */
  ARMV7A = 6,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7M = 7;
   */
  ARMV7M = 7,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8A = 8;
   */
  ARMV8A = 8,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8M = 9;
   */
  ARMV8M = 9,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9A = 10;
   */
  ARMV9A = 10,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9M = 11;
   */
  ARMV9M = 11,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_X390X = 12;
   */
  X390X = 12,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_PPC64 = 13;
   */
  PPC64 = 13,

  /**
   * @generated from enum value: CRYPTO_IMPLEMENTATION_PLATFORM_PPC64LE = 14;
   */
  PPC64LE = 14,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform)
proto3.util.setEnumType(CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform, "cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoImplementationPlatform", [
  { no: 0, name: "CRYPTO_IMPLEMENTATION_PLATFORM_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_IMPLEMENTATION_PLATFORM_UNKNOWN" },
  { no: 2, name: "CRYPTO_IMPLEMENTATION_PLATFORM_OTHER" },
  { no: 3, name: "CRYPTO_IMPLEMENTATION_PLATFORM_GENERIC" },
  { no: 4, name: "CRYPTO_IMPLEMENTATION_PLATFORM_X86_32" },
  { no: 5, name: "CRYPTO_IMPLEMENTATION_PLATFORM_X86_64" },
  { no: 6, name: "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7A" },
  { no: 7, name: "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7M" },
  { no: 8, name: "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8A" },
  { no: 9, name: "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8M" },
  { no: 10, name: "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9A" },
  { no: 11, name: "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9M" },
  { no: 12, name: "CRYPTO_IMPLEMENTATION_PLATFORM_X390X" },
  { no: 13, name: "CRYPTO_IMPLEMENTATION_PLATFORM_PPC64" },
  { no: 14, name: "CRYPTO_IMPLEMENTATION_PLATFORM_PPC64LE" },
]);

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoAlgorithmMode
 */
export enum CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode {
  /**
   * ProtoBuff's default value -- it differs from "unknown"
   *
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The mode of operation is not known
   *
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * Another mode of operation - none of the following
   *
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_OTHER = 2;
   */
  OTHER = 2,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_CBC = 3;
   */
  CBC = 3,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_ECB = 4;
   */
  ECB = 4,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_CCM = 5;
   */
  CCM = 5,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_GCM = 6;
   */
  GCM = 6,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_CFB = 7;
   */
  CFB = 7,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_OFB = 8;
   */
  OFB = 8,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_MODE_CTR = 9;
   */
  CTR = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode)
proto3.util.setEnumType(CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode, "cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoAlgorithmMode", [
  { no: 0, name: "CRYPTO_ALGORITHM_MODE_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_ALGORITHM_MODE_UNKNOWN" },
  { no: 2, name: "CRYPTO_ALGORITHM_MODE_OTHER" },
  { no: 3, name: "CRYPTO_ALGORITHM_MODE_CBC" },
  { no: 4, name: "CRYPTO_ALGORITHM_MODE_ECB" },
  { no: 5, name: "CRYPTO_ALGORITHM_MODE_CCM" },
  { no: 6, name: "CRYPTO_ALGORITHM_MODE_GCM" },
  { no: 7, name: "CRYPTO_ALGORITHM_MODE_CFB" },
  { no: 8, name: "CRYPTO_ALGORITHM_MODE_OFB" },
  { no: 9, name: "CRYPTO_ALGORITHM_MODE_CTR" },
]);

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoAlgorithmPadding
 */
export enum CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding {
  /**
   * ProtoBuff's default value -- it differs from "unknown"
   *
   * @generated from enum value: CRYPTO_ALGORITHM_PADDING_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The padding scheme is not known
   *
   * @generated from enum value: CRYPTO_ALGORITHM_PADDING_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * Another padding scheme - none of the following
   *
   * @generated from enum value: CRYPTO_ALGORITHM_PADDING_OTHER = 2;
   */
  OTHER = 2,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_PADDING_PKCS5 = 3;
   */
  PKCS5 = 3,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_PADDING_PKCS7 = 4;
   */
  PKCS7 = 4,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_PADDING_PKCS1V15 = 5;
   */
  PKCS1V15 = 5,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_PADDING_OAEP = 6;
   */
  OAEP = 6,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_PADDING_RAW = 7;
   */
  RAW = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding)
proto3.util.setEnumType(CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding, "cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoAlgorithmPadding", [
  { no: 0, name: "CRYPTO_ALGORITHM_PADDING_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_ALGORITHM_PADDING_UNKNOWN" },
  { no: 2, name: "CRYPTO_ALGORITHM_PADDING_OTHER" },
  { no: 3, name: "CRYPTO_ALGORITHM_PADDING_PKCS5" },
  { no: 4, name: "CRYPTO_ALGORITHM_PADDING_PKCS7" },
  { no: 5, name: "CRYPTO_ALGORITHM_PADDING_PKCS1V15" },
  { no: 6, name: "CRYPTO_ALGORITHM_PADDING_OAEP" },
  { no: 7, name: "CRYPTO_ALGORITHM_PADDING_RAW" },
]);

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoAlgorithmFunction
 */
export enum CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction {
  /**
   * ProtoBuff's default value -- it differs from "unknown"
   *
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * meaning "there is some, but it is unclear which one"
   *
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * none of the following
   *
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_OTHER = 2;
   */
  OTHER = 2,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_GENERATE = 3;
   */
  GENERATE = 3,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_KEYGEN = 4;
   */
  KEYGEN = 4,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_ENCRYPT = 5;
   */
  ENCRYPT = 5,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_DECRYPT = 6;
   */
  DECRYPT = 6,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_DIGEST = 7;
   */
  DIGEST = 7,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_TAG = 8;
   */
  TAG = 8,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_KEYDERIVE = 9;
   */
  KEYDERIVE = 9,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_SIGN = 10;
   */
  SIGN = 10,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_VERIFY = 11;
   */
  VERIFY = 11,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_ENCAPSULATE = 12;
   */
  ENCAPSULATE = 12,

  /**
   * @generated from enum value: CRYPTO_ALGORITHM_FUNCTION_DECAPSULATE = 13;
   */
  DECAPSULATE = 13,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction)
proto3.util.setEnumType(CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction, "cyclonedx.v1_6.CryptoProperties.AlgorithmProperties.CryptoAlgorithmFunction", [
  { no: 0, name: "CRYPTO_ALGORITHM_FUNCTION_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_ALGORITHM_FUNCTION_UNKNOWN" },
  { no: 2, name: "CRYPTO_ALGORITHM_FUNCTION_OTHER" },
  { no: 3, name: "CRYPTO_ALGORITHM_FUNCTION_GENERATE" },
  { no: 4, name: "CRYPTO_ALGORITHM_FUNCTION_KEYGEN" },
  { no: 5, name: "CRYPTO_ALGORITHM_FUNCTION_ENCRYPT" },
  { no: 6, name: "CRYPTO_ALGORITHM_FUNCTION_DECRYPT" },
  { no: 7, name: "CRYPTO_ALGORITHM_FUNCTION_DIGEST" },
  { no: 8, name: "CRYPTO_ALGORITHM_FUNCTION_TAG" },
  { no: 9, name: "CRYPTO_ALGORITHM_FUNCTION_KEYDERIVE" },
  { no: 10, name: "CRYPTO_ALGORITHM_FUNCTION_SIGN" },
  { no: 11, name: "CRYPTO_ALGORITHM_FUNCTION_VERIFY" },
  { no: 12, name: "CRYPTO_ALGORITHM_FUNCTION_ENCAPSULATE" },
  { no: 13, name: "CRYPTO_ALGORITHM_FUNCTION_DECAPSULATE" },
]);

/**
 * @generated from message cyclonedx.v1_6.CryptoProperties.CertificateProperties
 */
export class CryptoProperties_CertificateProperties extends Message<CryptoProperties_CertificateProperties> {
  /**
   * The subject name for the certificate
   *
   * @generated from field: optional string subjectName = 1;
   */
  subjectName?: string;

  /**
   * The issuer name for the certificate
   *
   * @generated from field: optional string issuerName = 2;
   */
  issuerName?: string;

  /**
   * The date and time according to ISO-8601 standard from which the certificate is valid
   *
   * @generated from field: optional google.protobuf.Timestamp notValidBefore = 3;
   */
  notValidBefore?: Timestamp;

  /**
   * The date and time according to ISO-8601 standard from which the certificate is not valid anymore
   *
   * @generated from field: optional google.protobuf.Timestamp notValidAfter = 4;
   */
  notValidAfter?: Timestamp;

  /**
   * The bom-ref to signature algorithm used by the certificate
   *
   * @generated from field: optional string signatureAlgorithmRef = 5;
   */
  signatureAlgorithmRef?: string;

  /**
   * The bom-ref to the public key of the subject
   *
   * @generated from field: optional string subjectPublicKeyRef = 6;
   */
  subjectPublicKeyRef?: string;

  /**
   * The format of the certificate. Examples include X.509, PEM, DER, and CVC.
   *
   * @generated from field: optional string certificateFormat = 7;
   */
  certificateFormat?: string;

  /**
   * The file extension of the certificate. Examples include crt, pem, cer, der, and p12.
   *
   * @generated from field: optional string certificateExtension = 8;
   */
  certificateExtension?: string;

  constructor(data?: PartialMessage<CryptoProperties_CertificateProperties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.CryptoProperties.CertificateProperties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subjectName", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "issuerName", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "notValidBefore", kind: "message", T: Timestamp, opt: true },
    { no: 4, name: "notValidAfter", kind: "message", T: Timestamp, opt: true },
    { no: 5, name: "signatureAlgorithmRef", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "subjectPublicKeyRef", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "certificateFormat", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "certificateExtension", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoProperties_CertificateProperties {
    return new CryptoProperties_CertificateProperties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoProperties_CertificateProperties {
    return new CryptoProperties_CertificateProperties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoProperties_CertificateProperties {
    return new CryptoProperties_CertificateProperties().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoProperties_CertificateProperties | PlainMessage<CryptoProperties_CertificateProperties> | undefined, b: CryptoProperties_CertificateProperties | PlainMessage<CryptoProperties_CertificateProperties> | undefined): boolean {
    return proto3.util.equals(CryptoProperties_CertificateProperties, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties
 */
export class CryptoProperties_RelatedCryptoMaterialProperties extends Message<CryptoProperties_RelatedCryptoMaterialProperties> {
  /**
   * The type for the related cryptographic material
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties.CryptoRelatedType type = 1;
   */
  type?: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType;

  /**
   * The optional unique identifier for the related cryptographic material.
   *
   * @generated from field: optional string id = 2;
   */
  id?: string;

  /**
   * The key state as defined by NIST SP 800-57.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties.CryptoRelatedState state = 3;
   */
  state?: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState;

  /**
   * The bom-ref to the algorithm used to generate the related cryptographic material.
   *
   * @generated from field: optional string algorithmRef = 4;
   */
  algorithmRef?: string;

  /**
   * The date and time (timestamp) when the related cryptographic material was created.
   *
   * @generated from field: optional google.protobuf.Timestamp creationDate = 5;
   */
  creationDate?: Timestamp;

  /**
   * The date and time (timestamp) when the related cryptographic material was activated.
   *
   * @generated from field: optional google.protobuf.Timestamp activationDate = 6;
   */
  activationDate?: Timestamp;

  /**
   * The date and time (timestamp) when the related cryptographic material was updated.
   *
   * @generated from field: optional google.protobuf.Timestamp updateDate = 7;
   */
  updateDate?: Timestamp;

  /**
   * The date and time (timestamp) when the related cryptographic material expires.
   *
   * @generated from field: optional google.protobuf.Timestamp expirationDate = 8;
   */
  expirationDate?: Timestamp;

  /**
   * The associated value of the cryptographic material.
   *
   * @generated from field: optional string value = 9;
   */
  value?: string;

  /**
   * The size of the cryptographic asset (in bits).
   *
   * @generated from field: optional int64 size = 10;
   */
  size?: bigint;

  /**
   * The format of the related cryptographic material (e.g. P8, PEM, DER).
   *
   * @generated from field: optional string format = 11;
   */
  format?: string;

  /**
   * The mechanism by which the cryptographic asset is secured.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties.CryptoRelatedSecuredBy securedBy = 12;
   */
  securedBy?: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy;

  constructor(data?: PartialMessage<CryptoProperties_RelatedCryptoMaterialProperties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType), opt: true },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState), opt: true },
    { no: 4, name: "algorithmRef", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "creationDate", kind: "message", T: Timestamp, opt: true },
    { no: 6, name: "activationDate", kind: "message", T: Timestamp, opt: true },
    { no: 7, name: "updateDate", kind: "message", T: Timestamp, opt: true },
    { no: 8, name: "expirationDate", kind: "message", T: Timestamp, opt: true },
    { no: 9, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "size", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 11, name: "format", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 12, name: "securedBy", kind: "message", T: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoProperties_RelatedCryptoMaterialProperties {
    return new CryptoProperties_RelatedCryptoMaterialProperties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoProperties_RelatedCryptoMaterialProperties {
    return new CryptoProperties_RelatedCryptoMaterialProperties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoProperties_RelatedCryptoMaterialProperties {
    return new CryptoProperties_RelatedCryptoMaterialProperties().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoProperties_RelatedCryptoMaterialProperties | PlainMessage<CryptoProperties_RelatedCryptoMaterialProperties> | undefined, b: CryptoProperties_RelatedCryptoMaterialProperties | PlainMessage<CryptoProperties_RelatedCryptoMaterialProperties> | undefined): boolean {
    return proto3.util.equals(CryptoProperties_RelatedCryptoMaterialProperties, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties.CryptoRelatedType
 */
export enum CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType {
  /**
   * ProtoBuff's default value -- it differs from "unknown"
   *
   * @generated from enum value: CRYPTO_RELATED_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The type of cryptographic asset is not known.
   *
   * @generated from enum value: CRYPTO_RELATED_TYPE_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * Another type of cryptographic asset - none of the following
   *
   * @generated from enum value: CRYPTO_RELATED_TYPE_OTHER = 2;
   */
  OTHER = 2,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_PRIVATE_KEY = 3;
   */
  PRIVATE_KEY = 3,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_PUBLIC_KEY = 4;
   */
  PUBLIC_KEY = 4,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_SECRET_KEY = 5;
   */
  SECRET_KEY = 5,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_KEY = 6;
   */
  KEY = 6,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_CIPHERTEXT = 7;
   */
  CIPHERTEXT = 7,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_SIGNATURE = 8;
   */
  SIGNATURE = 8,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_DIGEST = 9;
   */
  DIGEST = 9,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_INITIALIZATION_VECTOR = 10;
   */
  INITIALIZATION_VECTOR = 10,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_NONCE = 11;
   */
  NONCE = 11,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_SEED = 12;
   */
  SEED = 12,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_SALT = 13;
   */
  SALT = 13,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_SHARED_SECRET = 14;
   */
  SHARED_SECRET = 14,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_TAG = 15;
   */
  TAG = 15,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_ADDITIONAL_DATA = 16;
   */
  ADDITIONAL_DATA = 16,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_PASSWORD = 17;
   */
  PASSWORD = 17,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_CREDENTIAL = 18;
   */
  CREDENTIAL = 18,

  /**
   * @generated from enum value: CRYPTO_RELATED_TYPE_TOKEN = 19;
   */
  TOKEN = 19,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType)
proto3.util.setEnumType(CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType, "cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties.CryptoRelatedType", [
  { no: 0, name: "CRYPTO_RELATED_TYPE_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_RELATED_TYPE_UNKNOWN" },
  { no: 2, name: "CRYPTO_RELATED_TYPE_OTHER" },
  { no: 3, name: "CRYPTO_RELATED_TYPE_PRIVATE_KEY" },
  { no: 4, name: "CRYPTO_RELATED_TYPE_PUBLIC_KEY" },
  { no: 5, name: "CRYPTO_RELATED_TYPE_SECRET_KEY" },
  { no: 6, name: "CRYPTO_RELATED_TYPE_KEY" },
  { no: 7, name: "CRYPTO_RELATED_TYPE_CIPHERTEXT" },
  { no: 8, name: "CRYPTO_RELATED_TYPE_SIGNATURE" },
  { no: 9, name: "CRYPTO_RELATED_TYPE_DIGEST" },
  { no: 10, name: "CRYPTO_RELATED_TYPE_INITIALIZATION_VECTOR" },
  { no: 11, name: "CRYPTO_RELATED_TYPE_NONCE" },
  { no: 12, name: "CRYPTO_RELATED_TYPE_SEED" },
  { no: 13, name: "CRYPTO_RELATED_TYPE_SALT" },
  { no: 14, name: "CRYPTO_RELATED_TYPE_SHARED_SECRET" },
  { no: 15, name: "CRYPTO_RELATED_TYPE_TAG" },
  { no: 16, name: "CRYPTO_RELATED_TYPE_ADDITIONAL_DATA" },
  { no: 17, name: "CRYPTO_RELATED_TYPE_PASSWORD" },
  { no: 18, name: "CRYPTO_RELATED_TYPE_CREDENTIAL" },
  { no: 19, name: "CRYPTO_RELATED_TYPE_TOKEN" },
]);

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties.CryptoRelatedState
 */
export enum CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState {
  /**
   * Default
   *
   * @generated from enum value: CRYPTO_RELATED_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CRYPTO_RELATED_STATE_PRE_ACTIVATION = 1;
   */
  PRE_ACTIVATION = 1,

  /**
   * @generated from enum value: CRYPTO_RELATED_STATE_ACTIVE = 2;
   */
  ACTIVE = 2,

  /**
   * @generated from enum value: CRYPTO_RELATED_STATE_SUSPENDED = 3;
   */
  SUSPENDED = 3,

  /**
   * @generated from enum value: CRYPTO_RELATED_STATE_DEACTIVATED = 4;
   */
  DEACTIVATED = 4,

  /**
   * @generated from enum value: CRYPTO_RELATED_STATE_COMPROMISED = 5;
   */
  COMPROMISED = 5,

  /**
   * @generated from enum value: CRYPTO_RELATED_STATE_DESTROYED = 6;
   */
  DESTROYED = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState)
proto3.util.setEnumType(CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState, "cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties.CryptoRelatedState", [
  { no: 0, name: "CRYPTO_RELATED_STATE_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_RELATED_STATE_PRE_ACTIVATION" },
  { no: 2, name: "CRYPTO_RELATED_STATE_ACTIVE" },
  { no: 3, name: "CRYPTO_RELATED_STATE_SUSPENDED" },
  { no: 4, name: "CRYPTO_RELATED_STATE_DEACTIVATED" },
  { no: 5, name: "CRYPTO_RELATED_STATE_COMPROMISED" },
  { no: 6, name: "CRYPTO_RELATED_STATE_DESTROYED" },
]);

/**
 * @generated from message cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties.CryptoRelatedSecuredBy
 */
export class CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy extends Message<CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy> {
  /**
   * Specifies the mechanism by which the cryptographic asset is secured. Examples include HSM, TPM, SGX, Software, and None
   *
   * @generated from field: optional string mechanism = 1;
   */
  mechanism?: string;

  /**
   * The bom-ref to the algorithm.
   *
   * @generated from field: optional string algorithmRef = 2;
   */
  algorithmRef?: string;

  constructor(data?: PartialMessage<CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.CryptoProperties.RelatedCryptoMaterialProperties.CryptoRelatedSecuredBy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mechanism", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "algorithmRef", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy {
    return new CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy {
    return new CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy {
    return new CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy | PlainMessage<CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy> | undefined, b: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy | PlainMessage<CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy> | undefined): boolean {
    return proto3.util.equals(CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.CryptoProperties.ProtocolProperties
 */
export class CryptoProperties_ProtocolProperties extends Message<CryptoProperties_ProtocolProperties> {
  /**
   * The concrete protocol type.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.ProtocolProperties.CryptoProtocolType type = 1;
   */
  type?: CryptoProperties_ProtocolProperties_CryptoProtocolType;

  /**
   * The version of the protocol. Examples include 1.0, 1.2, and 1.99.
   *
   * @generated from field: optional string version = 2;
   */
  version?: string;

  /**
   * A list of cipher suites related to the protocol.
   *
   * @generated from field: repeated cyclonedx.v1_6.CryptoProperties.ProtocolProperties.CryptoProtocolCipherSuite cipherSuites = 3;
   */
  cipherSuites: CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite[] = [];

  /**
   * The IKEv2 transform types supported (types 1-4), defined in RFC7296 section 3.3.2, and additional properties.
   *
   * @generated from field: optional cyclonedx.v1_6.CryptoProperties.ProtocolProperties.Ikev2TransformTypes ikev2TransformTypes = 4;
   */
  ikev2TransformTypes?: CryptoProperties_ProtocolProperties_Ikev2TransformTypes;

  constructor(data?: PartialMessage<CryptoProperties_ProtocolProperties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.CryptoProperties.ProtocolProperties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(CryptoProperties_ProtocolProperties_CryptoProtocolType), opt: true },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "cipherSuites", kind: "message", T: CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite, repeated: true },
    { no: 4, name: "ikev2TransformTypes", kind: "message", T: CryptoProperties_ProtocolProperties_Ikev2TransformTypes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoProperties_ProtocolProperties {
    return new CryptoProperties_ProtocolProperties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoProperties_ProtocolProperties {
    return new CryptoProperties_ProtocolProperties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoProperties_ProtocolProperties {
    return new CryptoProperties_ProtocolProperties().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoProperties_ProtocolProperties | PlainMessage<CryptoProperties_ProtocolProperties> | undefined, b: CryptoProperties_ProtocolProperties | PlainMessage<CryptoProperties_ProtocolProperties> | undefined): boolean {
    return proto3.util.equals(CryptoProperties_ProtocolProperties, a, b);
  }
}

/**
 * @generated from enum cyclonedx.v1_6.CryptoProperties.ProtocolProperties.CryptoProtocolType
 */
export enum CryptoProperties_ProtocolProperties_CryptoProtocolType {
  /**
   * ProtoBuff's default value -- it differs from "unknown"
   *
   * @generated from enum value: CRYPTO_PROTOCOL_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The protocol type is not known
   *
   * @generated from enum value: CRYPTO_PROTOCOL_TYPE_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * Another protocol type - none of the following
   *
   * @generated from enum value: CRYPTO_PROTOCOL_TYPE_OTHER = 2;
   */
  OTHER = 2,

  /**
   * @generated from enum value: CRYPTO_PROTOCOL_TYPE_TLS = 3;
   */
  TLS = 3,

  /**
   * @generated from enum value: CRYPTO_PROTOCOL_TYPE_SSH = 4;
   */
  SSH = 4,

  /**
   * @generated from enum value: CRYPTO_PROTOCOL_TYPE_IPSEC = 5;
   */
  IPSEC = 5,

  /**
   * @generated from enum value: CRYPTO_PROTOCOL_TYPE_IKE = 6;
   */
  IKE = 6,

  /**
   * @generated from enum value: CRYPTO_PROTOCOL_TYPE_SSTP = 7;
   */
  SSTP = 7,

  /**
   * @generated from enum value: CRYPTO_PROTOCOL_TYPE_WPA = 8;
   */
  WPA = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoProperties_ProtocolProperties_CryptoProtocolType)
proto3.util.setEnumType(CryptoProperties_ProtocolProperties_CryptoProtocolType, "cyclonedx.v1_6.CryptoProperties.ProtocolProperties.CryptoProtocolType", [
  { no: 0, name: "CRYPTO_PROTOCOL_TYPE_UNSPECIFIED" },
  { no: 1, name: "CRYPTO_PROTOCOL_TYPE_UNKNOWN" },
  { no: 2, name: "CRYPTO_PROTOCOL_TYPE_OTHER" },
  { no: 3, name: "CRYPTO_PROTOCOL_TYPE_TLS" },
  { no: 4, name: "CRYPTO_PROTOCOL_TYPE_SSH" },
  { no: 5, name: "CRYPTO_PROTOCOL_TYPE_IPSEC" },
  { no: 6, name: "CRYPTO_PROTOCOL_TYPE_IKE" },
  { no: 7, name: "CRYPTO_PROTOCOL_TYPE_SSTP" },
  { no: 8, name: "CRYPTO_PROTOCOL_TYPE_WPA" },
]);

/**
 * @generated from message cyclonedx.v1_6.CryptoProperties.ProtocolProperties.CryptoProtocolCipherSuite
 */
export class CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite extends Message<CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite> {
  /**
   * A common name for the cipher suite. For example: TLS_DHE_RSA_WITH_AES_128_CCM
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * A list of algorithms related to the cipher suite. Use the bom-ref to the algorithm cryptographic asset.
   *
   * @generated from field: repeated string algorithms = 2;
   */
  algorithms: string[] = [];

  /**
   * A list of common identifiers for the cipher suite. For example: 0xC0 and 0x9E
   *
   * @generated from field: repeated string identifiers = 3;
   */
  identifiers: string[] = [];

  constructor(data?: PartialMessage<CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.CryptoProperties.ProtocolProperties.CryptoProtocolCipherSuite";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "algorithms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "identifiers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite {
    return new CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite {
    return new CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite {
    return new CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite | PlainMessage<CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite> | undefined, b: CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite | PlainMessage<CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite> | undefined): boolean {
    return proto3.util.equals(CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite, a, b);
  }
}

/**
 * @generated from message cyclonedx.v1_6.CryptoProperties.ProtocolProperties.Ikev2TransformTypes
 */
export class CryptoProperties_ProtocolProperties_Ikev2TransformTypes extends Message<CryptoProperties_ProtocolProperties_Ikev2TransformTypes> {
  /**
   * Transform Type 1: encryption algorithms
   *
   * @generated from field: repeated string encr = 1;
   */
  encr: string[] = [];

  /**
   * Transform Type 2: pseudorandom functions
   *
   * @generated from field: repeated string prf = 2;
   */
  prf: string[] = [];

  /**
   * Transform Type 3: integrity algorithms
   *
   * @generated from field: repeated string integ = 3;
   */
  integ: string[] = [];

  /**
   * Transform Type 4: Key Exchange Method (KE) per RFC9370, formerly called Diffie-Hellman Group (D-H)
   *
   * @generated from field: repeated string ke = 4;
   */
  ke: string[] = [];

  /**
   * Specifies if an Extended Sequence Number (ESN) is used.
   *
   * @generated from field: optional bool esn = 5;
   */
  esn?: boolean;

  /**
   * IKEv2 Authentication method
   *
   * @generated from field: repeated string auth = 6;
   */
  auth: string[] = [];

  constructor(data?: PartialMessage<CryptoProperties_ProtocolProperties_Ikev2TransformTypes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cyclonedx.v1_6.CryptoProperties.ProtocolProperties.Ikev2TransformTypes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encr", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "prf", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "integ", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ke", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "esn", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "auth", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoProperties_ProtocolProperties_Ikev2TransformTypes {
    return new CryptoProperties_ProtocolProperties_Ikev2TransformTypes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoProperties_ProtocolProperties_Ikev2TransformTypes {
    return new CryptoProperties_ProtocolProperties_Ikev2TransformTypes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoProperties_ProtocolProperties_Ikev2TransformTypes {
    return new CryptoProperties_ProtocolProperties_Ikev2TransformTypes().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoProperties_ProtocolProperties_Ikev2TransformTypes | PlainMessage<CryptoProperties_ProtocolProperties_Ikev2TransformTypes> | undefined, b: CryptoProperties_ProtocolProperties_Ikev2TransformTypes | PlainMessage<CryptoProperties_ProtocolProperties_Ikev2TransformTypes> | undefined): boolean {
    return proto3.util.equals(CryptoProperties_ProtocolProperties_Ikev2TransformTypes, a, b);
  }
}

